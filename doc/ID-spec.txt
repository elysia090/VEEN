VEEN Identity Layer (ID) v0.0.1
Principals, Realms, Context IDs, Orgs, and Bridging
(Overlay on VEEN v0.0.1, no wire-format changes)
	0.	Scope

This document defines the VEEN Identity Layer (ID) v0.0.1. ID is an overlay on VEEN v0.0.1 that provides:
	•	cryptographic principals and devices,
	•	realm-scoped pseudonymous account identifiers (context IDs),
	•	organizations, groups, and roles,
	•	handle and external-ID mapping,
	•	capability-based delegation and revocation,
	•	cross-hub and cross-realm identity bridging.

ID introduces only payload schemas and processing rules. It does not change VEEN core wire objects (MSG, RECEIPT, CHECKPOINT, cap_token) and does not alter VEEN invariants.

All identity semantics are carried as encrypted VEEN payloads and folded deterministically. Hubs remain blind to identity contents.
	1.	Notation and common rules

Ht(tag,x) = H(ascii(tag) || 0x00 || x) as in VEEN core.

Keys:
	•	principal_pk: Ed25519 public key (32 bytes) for a root identity (human or service).
	•	device_pk: Ed25519 public key (32 bytes) for a device.
	•	dh_pk: X25519 public key (32 bytes) for a device.

All payload bodies defined in this document are deterministic CBOR maps:
	•	exact key set and key order as listed per schema,
	•	minimal-length unsigned integers,
	•	definite-length byte strings and arrays,
	•	no floats,
	•	no CBOR tags,
	•	unknown keys MUST be rejected.

Events are folded per stream in a deterministic order:
	•	primarily by VEEN stream_seq,
	•	optionally refined by an explicit timestamp field (ts/updated_at) when defined,
	•	with a stable, implementation-defined tie-breaker if required (e.g. leaf_hash).

	2.	Identity model

ID separates the following layers:
	•	Principal: long-lived cryptographic root identity (principal_pk).
	•	Realm: identity scope for an application, tenant, or federation (realm_id).
	•	Context identity: realm-scoped pseudonymous account identifier (ctx_id).
	•	Devices: device_pk attached to a principal, used as authenticators.
	•	Organizations: org_id representing multi-account entities.
	•	Groups and roles: sets and labels over ctx_id for access control.
	•	Handles: human-readable identifiers mapped to ctx_id or org_id.
	•	External IDs: references to legacy IdPs or systems.

Applications SHOULD primarily interact with ctx_id and realm_id. Principals are used as cryptographic roots and are not necessarily exposed to applications.
	3.	Identifiers

3.1 Realm identifiers

A realm is a scope for context identities.

realm_id = Ht(“id/realm”, ascii(realm_name))

realm_name is an implementation-chosen UTF-8 string (e.g. “example-app”, “tenant-123”). Realm identifiers are 32-byte opaque values.

3.2 Principals

Each principal_pk defines a root identity. No derived identifier is required beyond principal_pk itself, but a stable reference can be defined if needed:

principal_id = Ht(“id/principal”, principal_pk)

principal_id is not required for protocol correctness and is informative.

3.3 Context identifiers (ctx_id)

For a principal_pk in a given realm_id:

ctx_id = Ht(“id/ctx”, principal_pk || realm_id)

Properties:
	•	ctx_id is 32 bytes.
	•	The same principal_pk yields different ctx_id for different realm_id.
	•	Within a realm_id, ctx_id is stable for the lifetime of principal_pk.
	•	No global user identifier is imposed; correlation across realms is optional and explicit.

Applications SHOULD treat ctx_id as the primary account identifier inside a realm.

3.4 Device identifiers

Each device keypair (device_sk, device_pk) and DH key (dh_sk, dh_pk) defines:

device_id = Ht(“id/device”, device_pk)

device_id is used only within identity payloads. On-wire VEEN MSG.client_id remains device_pk.

3.5 Organizations

An organization root key org_pk (Ed25519) defines:

org_id = Ht(“id/org”, org_pk)

org_id is stable for the lifetime of org_pk. For realm-scoped organizations, an additional scoped id MAY be used:

scoped_org_id = Ht(“id/org/realm”, org_id || realm_id)

When scoped_org_id is used, group and role bindings inside that realm MUST reference scoped_org_id, not bare org_id.

3.6 Groups

Groups are identified under an organization (scoped or not):

group_id = Ht(“id/group”, org_id || ascii(group_local_name))

group_local_name is a UTF-8 string chosen by the application and MUST be stable for the logical group’s lifetime.
	4.	Streams

4.1 Recommended identity streams

The following VEEN stream identifiers are RECOMMENDED:

stream_id_principal   = Ht(“id/stream/principal”, principal_pk)
stream_id_ctx         = Ht(“id/stream/ctx”, ctx_id || realm_id)
stream_id_org         = Ht(“id/stream/org”, org_id)
stream_id_handle_ns   = Ht(“id/stream/handle”, realm_id)

Implementations MAY merge multiple logical streams into one VEEN stream or split them further, as long as folding rules remain deterministic.

4.2 Labels

For each stream_id, labels are derived using VEEN’s label function from a routing_key and stream_id. Multiple labels MAY be used per stream_id (e.g. for sharding or epoching) if fold order is well defined.
	5.	Schemas

Schema identifiers (H is the VEEN-wide hash):

schema_principal      = H(“id.principal.v1”)
schema_device         = H(“id.device.v1”)
schema_ctx_profile    = H(“id.ctx.profile.v1”)
schema_org_profile    = H(“id.org.profile.v1”)
schema_group          = H(“id.group.v1”)
schema_role_binding   = H(“id.role.v1”)
schema_handle_map     = H(“id.handlemap.v1”)
schema_external_link  = H(“id.external.v1”)
schema_revocation     = H(“id.revoke.v1”)

Each schema is identified by setting payload_hdr.schema to the corresponding hash value. All payload_hdr and body data are AEAD-protected inside the VEEN ciphertext.
	6.	Principals and devices

6.1 Principal record

Schema: schema_principal
Stream: stream_id_principal

Body:

{
principal_pk: bstr(32),
created_at: uint,        // unix time seconds
info: map?               // optional, application-defined
}

Rules:
	•	principal_pk MUST match the public key used to derive stream_id_principal.
	•	Multiple principal records MAY exist; later records MAY override info but MUST NOT change principal_pk.

6.2 Device record

Schema: schema_device
Stream: stream_id_principal

Body:

{
principal_pk: bstr(32),
device_id: bstr(32),      // Ht(“id/device”, device_pk)
device_pk: bstr(32),      // Ed25519
dh_pk: bstr(32),          // X25519
label: text?,             // e.g. “phone”, “laptop”
created_at: uint,
expires_at: uint?,        // unix time seconds
flags: { disabled: bool? }?
}

Rules:
	•	principal_pk MUST equal the principal_pk of stream_id_principal.
	•	device_id MUST equal Ht(“id/device”, device_pk).
	•	Device is ACTIVE if:
	•	flags.disabled is absent or false, and
	•	expires_at is absent or now <= expires_at.
	•	Folding:
	•	For each device_id, events are ordered as in section 1.
	•	The last event determines flags and expiry.

ACTIVE devices are permitted authenticators for ctx_id derived from the same principal_pk, subject to delegation via cap_token.
	7.	Context accounts (per-realm identities)

7.1 Context profile

Schema: schema_ctx_profile
Stream: stream_id_ctx

Body:

{
ctx_id: bstr(32),
realm_id: bstr(32),
display_name: text?,
avatar_coid: bstr(32)?,   // content object ID for avatar
prefs: map?,
updated_at: uint          // unix time seconds
}

Rules:
	•	ctx_id MUST equal Ht(“id/ctx”, principal_pk || realm_id) for some principal_pk; the principal linkage may be implicit or explicit (via delegation).
	•	realm_id MUST match the stream’s realm_id.
	•	CRDT semantics:
	•	For each (ctx_id, realm_id), the context profile is an LWW-register.
	•	The winner is the record with maximum (updated_at, stream_seq).
	•	Conflicts with equal (updated_at, stream_seq) MUST be treated as equivalent or rejected as duplicates.

Applications SHOULD read ctx_profile via stream_id_ctx and MUST NOT assume uniqueness of display_name.
	8.	Organizations, groups, and roles

8.1 Organization profile

Schema: schema_org_profile
Stream: stream_id_org

Body:

{
org_id: bstr(32),
display_name: text?,
metadata: map?,
created_at: uint,
updated_at: uint
}

Rules:
	•	org_id MUST match the org_id used to derive stream_id_org.
	•	Organization profile is an LWW-register per org_id using (updated_at, stream_seq).

8.2 Group membership

Schema: schema_group
Stream: stream_id_org or a realm-scoped variant

Body:

{
org_id: bstr(32),
realm_id: bstr(32)?,
group_id: bstr(32),
name: text,
members_add: [ bstr(32) ]?,      // ctx_id list
members_remove: [ bstr(32) ]?,   // ctx_id list
updated_at: uint
}

CRDT semantics:
	•	Group membership is an OR-set per (org_id, group_id).
	•	For each ctx_id:
	•	membership is true if there exists at least one add event listing ctx_id that is not fully tombstoned by later remove events listing the same ctx_id.
	•	Group name:
	•	name is LWW per (org_id, group_id) using (updated_at, stream_seq).

8.3 Role binding

Schema: schema_role_binding
Stream: stream_id_org or a realm-scoped variant

Body:

{
org_id: bstr(32),
realm_id: bstr(32)?,
role: text,                   // e.g. “admin”, “editor”
targets_ctx: [ bstr(32) ]?,   // ctx_id list
targets_group: [ bstr(32) ]?, // group_id list
ts: uint
}

Semantics:
	•	Roles are additive by default:
	•	For each ctx_id, assigned roles are:
	•	roles mentioned in events where ctx_id is in targets_ctx, and
	•	roles applied to group_id where ctx_id is a member.
	•	Explicit role revocation MAY be modeled by:
	•	a role naming convention (e.g. “no-admin”), or
	•	a separate revocation schema (implementation-specific).
	•	ID v0.0.1 does not define negative roles or hierarchical roles; these are left to applications.

	9.	Delegation and authentication

9.1 Delegation via cap_token

Delegation uses VEEN cap_token unchanged.

Issuer: principal_pk (for account-level delegation) or org_pk (for org-level delegation).
Subject: device_pk or a service key.

cap_token:

{
ver: 1,
issuer_pk: bstr(32),
subject_pk: bstr(32),
allow: {
stream_ids: [ bstr(32) … ],
ttl: uint,
rate: { per_sec: uint, burst: uint }?
},
sig_chain: [ 64-byte signatures … ]
}

Rules:
	•	For principal-based delegation:
	•	issuer_pk MUST equal principal_pk.
	•	subject_pk MUST equal device_pk of an ACTIVE device.
	•	allow.stream_ids SHOULD include required identity and application streams (including stream_id_ctx for relevant realms).
	•	For org-based delegation:
	•	issuer_pk MUST equal org_pk.
	•	subject_pk MAY be principal_pk, device_pk, or a service key.
	•	ttl and rate MUST be enforced by admission logic according to OP0.3-style policies.

9.2 Authentication path for ctx_id

To authenticate a client as a ctx_id in a realm:
	1.	Client submits MSG with:
	•	client_id = device_pk,
	•	MSG.sig signed by device_sk,
	•	optional auth_ref referencing a cap_token.
	2.	Application obtains cap_token via auth_ref and verifies:
	•	sig_chain matches issuer_pk root (principal_pk or org_pk),
	•	subject_pk equals device_pk,
	•	allow.stream_ids includes the target application/identity streams,
	•	ttl and optional rate are satisfied.
	3.	If issuer_pk is principal_pk:
	•	Application computes ctx_id_expected = Ht(“id/ctx”, principal_pk || realm_id).
	•	Application binds this session to ctx_id_expected.
	4.	Additionally, application SHOULD check:
	•	device_pk is ACTIVE in schema_device for principal_pk,
	•	any required org/group/role bindings are present.

The application does not need to store passwords, session IDs, or bearer tokens; possession of device_sk and a valid cap_token chain is sufficient.
	10.	Handles and external IDs

10.1 Handle mapping

Schema: schema_handle_map
Stream: stream_id_handle_ns for a given realm_id

Body:

{
realm_id: bstr(32),
handle: text,                    // “@user”, “user@example.com”, etc.
target_type: text,               // “ctx” or “org”
target_id: bstr(32),             // ctx_id or org_id
ts: uint
}

Semantics:
	•	The handle namespace is per realm_id.
	•	For each (realm_id, handle), mapping is an LWW-register:
	•	winner is record with maximum (ts, stream_seq).
	•	Implementations MUST define:
	•	which handles are valid (syntax),
	•	whether and how handles can be reassigned,
	•	how to handle conflicts or squatting.

10.2 External ID link

Schema: schema_external_link
Stream: stream_id_ctx (recommended) or stream_id_org

Body:

{
realm_id: bstr(32),
ctx_id: bstr(32)?,
org_id: bstr(32)?,
provider: text,                  // “google”, “github”, “saml:corp”, etc.
external_sub: text,              // subject from external IdP or system
attributes: map?,                // optional mirrored claims
ts: uint
}

Semantics:
	•	At least one of ctx_id or org_id MUST be present.
	•	For each (provider, external_sub) there SHOULD be at most one active linkage across trusted streams.
	•	On external login:
	•	a gateway validates the external token,
	•	locates or creates ctx_id in the target realm,
	•	emits or updates an external_link binding external_sub to ctx_id.

ID v0.0.1 does not define global uniqueness or trust policies for providers; deployments MUST define which providers are trusted and how conflicts are resolved.
	11.	Revocation and rotation

11.1 Revocation record

Schema: schema_revocation
Stream: stream_id_principal or stream_id_org

Body:

{
principal_pk: bstr(32)?,
org_id: bstr(32)?,
device_id: bstr(32)?,
revoked_auth_ref: bstr(32)?,
realm_id: bstr(32)?,
ctx_id: bstr(32)?,
reason: text?,
ts: uint
}

Rules:
	•	At least one of device_id, revoked_auth_ref, ctx_id, org_id MUST be present.
	•	Revocation is advisory and MUST be enforced by:
	•	hubs (for admission) and/or
	•	applications (for authorization decisions).

Recommended enforcement:
	•	If revoked_auth_ref matches auth_ref, hubs SHOULD deny /submit for that auth_ref.
	•	If device_id is revoked, applications MUST treat the corresponding device as INACTIVE even if schema_device flags are not updated.
	•	If ctx_id is revoked in a realm, applications SHOULD treat that ctx_id as disabled for that realm.

11.2 Device rotation

To rotate a device:
	•	Generate new device_pk2 / dh_pk2.
	•	Create a schema_device event for device_pk2 (ACTIVE).
	•	Create a schema_revocation event for old device_id and/or old revoked_auth_ref.
	•	Optionally disable old device via a schema_device record with flags.disabled = true.

11.3 Principal and organization key rotation

Principal and org key rotation are advanced operations and are not fully standardized in ID v0.0.1. A deployment MAY define:
	•	a dedicated key-rotation schema, and
	•	rules mapping old principal_pk/org_pk to new ones.

Until such schema exists, principal_pk and org_pk SHOULD be treated as long-lived roots.
	12.	Bridging and federation

12.1 Cross-hub identity mirroring

Bridging uses the VEEN bridging overlay.

A bridge process:
	•	subscribes to identity streams on hub A (principal, ctx, org, handle, external_link, revocation) using stream(with_proof=1),
	•	for each MSG:
	•	preserves payload_hdr.schema and payload body byte-for-byte,
	•	sets parent_id of the mirrored MSG to the original msg_id,
	•	publishes a new MSG to hub B on the corresponding identity stream.

Semantics:
	•	Logical identity state is the union of events from all trusted hubs.
	•	Events are deduplicated using a stable identifier:
	•	for example, (payload hash, parent_id) or original msg_id.
	•	The fold order MUST be deterministic across hubs.

12.2 Realm-level federation

Realms support multiple federation patterns:
	•	Single realm for all applications in a deployment.
	•	Per-tenant realm for multi-tenant SaaS.
	•	Per-product realm for independent products sharing principals at a higher layer.

Root-level federation (e.g. a “meta realm”) that links multiple realms via external_link is permitted but not specified in detail by ID v0.0.1.
	13.	Privacy

ID v0.0.1 aims to minimise implicit correlation:
	•	ctx_id differs per realm by construction.
	•	Principals are not required to be exposed to applications.
	•	Identity payloads are encrypted; hubs do not see principal_pk, ctx_id, org_id, or handles in plaintext.
	•	Cross-realm correlation is opt-in via external_link or application-specific logic.

Deployments SHOULD:
	•	avoid using principal_pk as a global account identifier in plaintext,
	•	scope handles per realm_id,
	•	use external_link only for explicit federation or legacy integration.

	14.	Compliance levels

An implementation MAY claim:
	•	“ID v0.0.1 Core” if it implements:
	•	realm_id and ctx_id derivation,
	•	schema_ctx_profile,
	•	schema_device,
	•	delegation and authentication as in section 9.
	•	“ID v0.0.1 Orgs” if it additionally implements:
	•	schema_org_profile,
	•	schema_group,
	•	schema_role_binding.
	•	“ID v0.0.1 Handles” if it additionally implements:
	•	schema_handle_map,
	•	resolve-by-handle logic.
	•	“ID v0.0.1 External” if it additionally implements:
	•	schema_external_link and a gateway for at least one external provider.
	•	“ID v0.0.1 Bridge” if it additionally implements:
	•	cross-hub identity mirroring as in section 12.1.

	15.	Summary

ID v0.0.1 defines a minimal, coherent identity layer for VEEN:
	•	cryptographic principals and devices as roots,
	•	realm-scoped pseudonymous context IDs (ctx_id) as primary account identifiers,
	•	organizations, groups, and roles as CRDT overlays,
	•	handle and external-ID mapping as additional overlays,
	•	delegation via cap_token and event-driven revocation,
	•	bridging across hubs and realms without changing VEEN wire formats.

