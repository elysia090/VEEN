VEEN CLI v0.0.1+ Operational Goal Specification (Tightened)
Plain ASCII, English only. Additive to VEEN CLI v0.0.1. No wire changes.
	0.	Scope

This document extends the VEEN CLI v0.0.1 Operational Goal Specification for deployments that implement VEEN v0.0.1+ overlays:
	•	FED1: Federated hubs and authority records
	•	AUTH1: Label authority and single-primary discipline
	•	KEX1+: Strengthened key and capability lifecycle
	•	SH1+: Extended hardening and admission pipeline
	•	LCLASS0: Label classification overlay
	•	META0+: Schema registry and discovery overlay

All v0.0.1 core CLI goals remain mandatory. v0.0.1+ goals are additional, not replacements.
A CLI implementation that satisfies both documents is “VEEN CLI v0.0.1+-complete”.
	1.	Global CLI conventions for v0.0.1+

1.1 Global flags

Every v0.0.1+ command MUST accept:
	•	–json : emit machine-readable JSON to stdout only, no extra text
	•	–quiet : suppress informational text and progress, print errors only
	•	–timeout-ms N : upper bound on HTTP / RPC round-trip per hub interaction

If both –json and –quiet are provided, –json governs output formatting, and errors MUST be JSON objects with fields:
	•	ok: false
	•	code: string
	•	detail: string?

1.2 Exit codes

The following exit codes are reserved:
	•	0   : success; all required checks passed
	•	1   : CLI usage error (missing flags, invalid combinations)
	•	2   : network or transport failure (hub not reachable, TLS error)
	•	3   : protocol error (malformed hub response)
	•	4   : hub-level logical error (E.* from hub or policy violation)
	•	5   : selftest failure (at least one test case failed)

Commands MAY use additional non-zero codes for finer-grained scripting but MUST treat 0 vs non-zero as success vs failure.

1.3 Determinism

For all v0.0.1+ commands:
	•	Given the same:
	•	CLI version
	•	command line arguments
	•	environment variables
	•	local filesystem tree
	•	hub state
	•	The observable outputs (stdout, stderr, exit code) MUST be bitwise identical.

Randomness (for ids, nonces) is allowed only when explicitly specified; selftests MUST control randomness via fixed seeds or explicit parameters.
	2.	Hub profile and role introspection

2.1 Hub feature profile

Command:

veen hub profile
–hub http://host:port
[–json]

Requirements:
	•	Perform a single request to obtain a v0.0.1+ capability descriptor. Mechanism is implementation-defined (HTTP endpoint, RPC schema, or admin label), but MUST be documented.
	•	On success, emit:

Human-readable (default):

version: veen-0.0.1+
profile_id: HEX32
hub_id: HEX32
features:
core: true|false
fed1: true|false
auth1: true|false
kex1_plus: true|false
sh1_plus: true|false
lclass0: true|false
meta0_plus: true|false

JSON (–json):

{
“ok”: true,
“version”: “veen-0.0.1+”,
“profile_id”: “HEX32”,
“hub_id”: “HEX32”,
“features”: {
“core”: true,
“fed1”: true,
“auth1”: true,
“kex1_plus”: true,
“sh1_plus”: true,
“lclass0”: true,
“meta0_plus”: true
}
}

Errors:
	•	If hub does not support profile introspection: exit 4 with code “E.PROFILE” in JSON or text.

2.2 Hub role for realm/stream

Command:

veen hub role
–hub http://host:port
[–realm HEX32]
[–stream STREAM_NAME]
[–json]

Definitions:
	•	stream_id = deterministic mapping from STREAM_NAME to bstr(32); same mapping as used by veen send.
	•	realm_id:
	•	if –realm provided: parsed from HEX32
	•	else: hub default realm (implementation-defined but must be documented)

Behavior:
	•	With no –stream:
	•	Print a coarse hub role summary, such as:
	•	role: “standalone”
	•	or role: “federated-primary”, “federated-replica”, “observer”
	•	With –stream:
	•	Compute stream_id and associated label mapping (same as send).
	•	Ask hub for label_authority(label) under AUTH1.
	•	Emit:

Human-readable:

hub_id: HEX32
realm_id: HEX32
stream_id: HEX32
label: HEX32
policy: single-primary|multi-primary|unspecified
primary_hub: HEX32 or “none”
local_is_primary: true|false

JSON:

{
“ok”: true,
“hub_id”: “HEX32”,
“realm_id”: “HEX32”,
“stream_id”: “HEX32”,
“label”: “HEX32”,
“policy”: “single-primary”,
“primary_hub”: “HEX32”,
“local_is_primary”: true
}

Constraints:
	•	If AUTH1 is not enabled on the hub:
	•	Exit 4 with code “E.PROFILE” (text or JSON).
	•	CLI MUST NOT guess policy locally; it MUST use hub view or fail explicitly.

	3.	Federation and authority management (FED1, AUTH1)

3.1 Publish authority record

Command:

veen fed authority publish
–hub http://host:port
–realm HEX32
–stream STREAM_NAME
–primary-hub HUB_ID_HEX32
[–replica-hub HUB_ID_HEX32 …]
–policy single-primary|multi-primary
–ttl SECONDS
[–ts UNIX_TIME]
–admin /path/to/admin-client
[–json]

Preconditions:
	•	admin client directory exists and is a valid VEEN client identity.
	•	Admin client has a capability that authorizes writing veen.fed.authority.v1 to the admin stream for given realm.

Behavior:
	•	Compute:
	•	realm_id from –realm
	•	stream_id from STREAM_NAME mapping
	•	Build veen.fed.authority.v1 body:
{
realm_id: bstr(32),
stream_id: bstr(32),
primary_hub: bstr(32),
replica_hubs: [bstr(32)…],
policy: text,
ts: uint (UNIX_TIME or now),
ttl: uint
}
	•	Send as MSG using admin client on stream_fed_admin (derived from realm_id).
	•	Verify RECEIPT locally (hub_sig, invariants).
	•	Optionally refresh authority view (see 3.2).

Postconditions:
	•	On success, print the active record chosen by the hub (after tie-breaking).
	•	On failure due to capability or policy, propagate code (E.AUTH, E.CAP, etc).

3.2 Show authority record for realm/stream

Command:

veen fed authority show
–hub http://host:port
–realm HEX32
–stream STREAM_NAME
[–json]

Behavior:
	•	Compute realm_id and stream_id.
	•	Query hub for its authority_view[(realm_id, stream_id)] (folded from veen.fed.authority.v1 stream).
	•	Emit:

Human-readable:

realm_id: HEX32
stream_id: HEX32
primary_hub: HEX32 or “none”
replica_hubs: [HEX32,…] or []
policy: single-primary|multi-primary|unspecified
ts: uint
ttl: uint
expires_at: uint
active_now: true|false

JSON with the same fields.

Edge cases:
	•	If no record exists, CLI prints policy: “unspecified” and active_now: false and exits 0.

3.3 Label authority by label

Command:

veen label authority
–hub http://host:port
–label HEX32
[–json]

Behavior:
	•	Request label_authority(L) from hub for label = HEX32.
	•	Emit:
label: HEX32
realm_id: HEX32 or “unspecified”
stream_id: HEX32
policy: single-primary|multi-primary|unspecified
primary_hub: HEX32 or “none”
local_hub_id: HEX32
locally_authorized: true|false

Use case:
	•	Diagnose “not primary for label” rejections and misconfigured federation.

	4.	Key and capability lifecycle (KEX1+)

4.1 Hub key and capability policy

Command:

veen hub kex-policy
–hub http://host:port
[–json]

Behavior:
	•	Query KEX1+ policy summary:
max_client_id_lifetime_sec: uint
max_msgs_per_client_id_per_label: uint
default_cap_ttl_sec: uint
max_cap_ttl_sec: uint
revocation_stream: stream name or label description
rotation_window_sec: uint (for hub key rotation) or 0 if not used
	•	CLI MUST treat absence of values as “unspecified” and show them as null in JSON.

4.2 Client identity usage summary

Command:

veen id usage
–client /path/to/client
[–hub http://host:port]
[–json]

Behavior:
	•	Read local state for the client (per-label send metadata).
	•	Optionally, if –hub provided, fetch KEX1+ policy and apply thresholds.

Output per label:

label: HEX32
stream: logical name if known, else “-”
client_id: HEX32
created_at: uint or 0 if unknown
msgs_sent: uint
approx_lifetime_sec: uint or 0 if unknown
exceeds_msg_bound: true|false (if policy known)
exceeds_lifetime_bound: true|false (if policy known)
rotation_recommended: true|false

Exit behavior:
	•	Exit code 0 even if rotation is recommended; the command is informational only.

4.3 Capability validity and hub view

Command:

veen cap status
–hub http://host:port
–cap cap.cbor
[–json]

Behavior:
	•	Load cap_token from cap.cbor.
	•	Compute auth_ref = Ht(“veen/cap”, CBOR(cap_token)).
	•	Derive local validity window:
	•	issued_at:
	•	if explicit field inside cap_token: use it
	•	else: unknown
	•	ttl from cap_token.allow.ttl
	•	Query hub via an inspection RPC or admin endpoint:
request: auth_ref
response fields:
known: bool
currently_valid: bool
revoked: bool
expiry: uint? (hub view)
revocation_kind: “client-id”|“auth-ref”|“cap-token”|null
revocation_ts: uint?
reason: text?

Compose output:

Human:

auth_ref: HEX32
locally_within_ttl: true|false|“unknown”
hub_known: true|false
hub_currently_valid: true|false
revoked: true|false
revocation_kind: …
expires_at: uint or “unknown”
reason: text?

JSON includes all fields plus an “ok”: true flag.

4.4 Publish revocation record

Command:

veen cap revoke
–hub http://host:port
–admin /path/to/admin-client
–kind client-id|auth-ref|cap-token
–target HEX32
[–reason TEXT]
[–ttl SECONDS]
[–json]

Behavior:
	•	Build veen.revocation.v1:
{
kind: text,
target: bstr(32),
reason: text?,
ts: now,
ttl: uint?
}
	•	Send via admin client on stream_revocation.
	•	Verify RECEIPT and invariants.
	•	Print:
kind, target, ts, ttl, active_now: bool

4.5 List revocations

Command:

veen cap revocations
–hub http://host:port
[–kind client-id|auth-ref|cap-token]
[–since UNIX_TIME]
[–active-only]
[–limit N]
[–json]

Behavior:
	•	Read revocation stream up to configured limit (or N).
	•	Fold to current active window at local “now”.
	•	Filter by:
	•	kind (if provided)
	•	ts >= since (if provided)
	•	active_now (if –active-only)
	•	Emit a table or JSON list of:
kind, target, ts, ttl, active_now, reason

	5.	Admission pipeline inspection (SH1+)

5.1 Admission stages overview

Command:

veen hub admission
–hub http://host:port
[–json]

Behavior:
	•	Query hub admission configuration and runtime metrics.
	•	Emit per stage:
stage:
name: text (“stage0-prefilter” etc)
enabled: bool
responsibilities: [text]
queue_depth: uint
max_queue_depth: uint
recent_err_rates:
E.SIZE: float?
E.SIG: float?
E.AUTH: float?
E.CAP: float?
E.RATE: float?

JSON uses arrays and objects with the same fields.

5.2 Proof-of-work challenge and solver

Command:

veen pow request
–hub http://host:port
[–difficulty D]
[–json]

Behavior:
	•	Ask the hub (or PoW endpoint) for:
	•	challenge: bytes
	•	difficulty: uint8 (recommended difficulty)
	•	Emit:

Human:

challenge: HEX
difficulty: D

JSON:

{ “ok”: true, “challenge”: “HEX”, “difficulty”: D }

Command:

veen pow solve
–challenge HEX
–difficulty D
[–max-iterations N]
[–json]

Behavior:
	•	Iterate nonce from 0 upward (or within a bounded range if –max-iterations is supplied).
	•	For each nonce:
v = Ht(“veen/pow”, challenge || u64be(nonce))
Check that the first D bits of v are zero.
	•	On success:
	•	Print nonce (decimal and hex) and v (optional) in human mode.
	•	JSON:
{ “ok”: true, “nonce”: NONCE, “nonce_hex”: “HEX”, “hash_prefix_ok”: true }
	•	If no solution within bound: exit 4 with an error message.

5.3 Using PoW with send

All send-like commands (veen send, veen rpc call, etc.) MUST accept optional PoW parameters:
	•	–pow-challenge HEX
	•	–pow-nonce NONCE
	•	–pow-difficulty D

Transport binding of PoW cookie is deployment-specific. CLI MUST:
	•	Attach these parameters exactly as hub expects (e.g., header, RPC field, or side-channel).
	•	Not alter MSG encoding, RECEIPT handling, or VEEN invariants.

5.4 Admission-log sampling

Command:

veen hub admission-log
–hub http://host:port
[–limit N]
[–codes CODE1,CODE2,…]
[–json]

Behavior:
	•	Fetch a recent window of failed admission events via:
	•	a dedicated observability RPC, or
	•	a VEEN audit stream filtered by E.* codes.
	•	Display per event:
ts: uint
code: “E.*”
label_prefix: first 8 hex chars
client_id_prefix: first 8 hex chars
detail: short text

Use case: confirm that AUTH1, KEX1+, SH1+ policies are actually enforced and that failures are visible.
	6.	Label classification overlay (LCLASS0)

6.1 Set label classification

Command:

veen label-class set
–hub http://host:port
–realm HEX32
–label HEX32
–class TEXT
[–sensitivity low|medium|high]
[–retention-hint SECONDS]
–admin /path/to/admin-client
[–json]

Behavior:
	•	Build veen.label.class.v1:
{
label: bstr(32),
class: text,
sensitivity: text?,
retention_hint: uint?
}
	•	Publish on stream_label_class for the realm via admin client.
	•	Verify RECEIPT.
	•	Optionally re-query hub for effective classification and print it.

6.2 Show label classification

Command:

veen label-class show
–hub http://host:port
–label HEX32
[–json]

Behavior:
	•	Query hub classification view for the label.
	•	Emit:
label: HEX32
class: TEXT or “unset”
sensitivity: TEXT or “none”
retention_hint: uint or 0
pad_block_effective: uint
retention_policy: TEXT
rate_policy: TEXT
	•	CLI MUST treat hub values as authoritative; no local heuristics.
	•	Default output is human-readable text; use “–json” for machine-readable descriptors.

6.3 List label classifications

Command:

veen label-class list
–hub http://host:port
[–realm HEX32]
[–class TEXT]
[–json]

Behavior:
	•	Query all known label classifications in the realm or deployment.
	•	Filter by class if provided.
	•	Print a compact table or JSON array of:
label, class, sensitivity, retention_hint
	•	“–json” returns the descriptor entries as an array for automation.

	7.	Schema registry overlay (META0+)

7.1 Register schema descriptor

Command:

veen schema register
–hub http://host:port
–realm HEX32
–name TEXT
–version TEXT
[–doc-url TEXT]
[–owner HEX32]
[–schema-id HEX32]
–admin /path/to/admin-client
[–json]

Behavior:
	•	schema_id selection:
	•	if –schema-id provided: parse HEX32.
	•	else: schema_id = H(“veen/schema:” || name) or equivalent documented rule.
	•	Build veen.meta.schema.v1:
{
schema_id: bstr(32),
name: text,
version: text,
doc_url: text?,
owner: bstr(32)?,
ts: now
}
	•	Publish on stream_schema_meta via admin client.
	•	Verify RECEIPT.
	•	Emit the registered descriptor (including schema_id).

7.2 Show schema descriptor

Command:

veen schema show
–hub http://host:port
–schema-id HEX32
[–json]

Behavior:
	•	Lookup schema_id in hub registry.
	•	Emit:
schema_id: HEX32
name: TEXT
version: TEXT
doc_url: TEXT or “none”
owner: HEX32 or “none”
ts: uint
used_labels: [HEX32,…]?   (optional summary)
used_count: uint?           (approximate)

If schema_id is unknown, exit 4 with code “E.SEQ” or “E.PROFILE”.

7.3 List schemas

Command:

veen schema list
–hub http://host:port
[–realm HEX32]
[–name-prefix TEXT]
[–owner HEX32]
[–json]

Behavior:
	•	List schema descriptors matching filters.
	•	Provide at least:
schema_id, name, version, owner, ts

7.4 Schema usage inspection (optional but recommended)

Command:

veen schema usage
–hub http://host:port
–schema-id HEX32
[–stream STREAM_NAME]
[–since UNIX_TIME]
[–limit N]
[–json]

Behavior:
	•	Optionally implemented to scan recent messages and show where a schema is used (labels, counts).
	•	Pure overlay; no wire changes.

	8.	Extended self tests for v0.0.1+

8.1 Federated behavior (FED1, AUTH1)

Command:

veen selftest federated
[–json]

Behavior:
	•	Start two temporary hubs (hubA, hubB) with shared realm and distinct hub_ids.
	•	Run the following deterministic sequence:
	•	Publish authority record pointing primary_hub = hubA for test stream S.
	•	Confirm via:
	•	veen fed authority show
	•	veen hub role –stream S
	•	Using a client:
	•	Send MSG for S to hubA: MUST succeed.
	•	Send MSG for S to hubB: MUST fail with E.AUTH or E.CAP.
	•	Switch primary_hub to hubB in a new authority record (higher ts).
	•	Confirm authority view flips.
	•	Repeat send tests with reversed roles.
	•	If any check fails, exit 5 and report failing step.

8.2 Lifecycle and revocation (KEX1+)

Command:

veen selftest kex1
[–json]

Behavior:
	•	Start a hub with KEX1+ enabled and tight bounds for test (e.g. max_msgs_per_client_id_per_label = 3).
	•	Generate a client and capability.
	•	Test:
	•	Send up to the bound: all succeed.
	•	One additional send: hub MUST reject with E.CAP/E.AUTH; CLI verifies.
	•	Issue a short-ttl capability; after expiry, confirm rejection.
	•	Publish revocations for:
	•	client-id
	•	auth-ref
	•	Confirm that subsequent sends with revoked identity or capability fail.
	•	Collect all steps in a JSON summary when –json is provided.

8.3 Hardening behavior (SH1+)

Command:

veen selftest hardened
[–json]

Behavior:
	•	Against a hub with SH1+ enabled:
	•	Send oversized MSG:
	•	Ensure E.SIZE is returned; hub remains responsive.
	•	Send malformed CBOR:
	•	Ensure E.SIZE or equivalent structural error, no crash.
	•	If PoW is configured:
	•	Call veen pow request, then veen pow solve for a small difficulty.
	•	Send a batch of MSG with valid PoW: majority MUST succeed.
	•	Send similar batch without PoW: hub SHOULD throttle or reject with policy-specific errors.
	•	Selftest reports whether bounds-first behavior holds (size check before Ed25519/HPKE).

8.4 Label and schema overlays (LCLASS0, META0+)

Command:

veen selftest meta
[–json]

Behavior:
	•	Start ephemeral hub with all meta overlays enabled.
	•	For a test label:
	•	Use veen label-class set to define a class and retention hint.
	•	Confirm via label-class show and hub metrics that the policy is recognized.
	•	For a test schema:
	•	Use veen schema register to register “test.operation.v1”.
	•	Send a MSG with payload_hdr.schema equal to that id.
	•	Confirm via schema show and schema list that the schema appears and has non-zero usage.

8.5 Aggregated v0.0.1+ test suite

Command:

veen selftest plus
[–json]

Behavior:
	•	Equivalent to:
	•	veen selftest core
	•	veen selftest props
	•	veen selftest fuzz
	•	veen selftest federated
	•	veen selftest kex1
	•	veen selftest hardened
	•	veen selftest meta
	•	Exit 0 only if all subtests succeed.

	9.	v0.0.1+ completeness criteria

The VEEN CLI is v0.0.1+-complete if and only if:
	1.	All VEEN CLI v0.0.1 success criteria are met.
	2.	Every command specified in this document is implemented with:
	•	deterministic behavior
	•	correct use of VEEN wire types
	•	no modification of MSG, RECEIPT, CHECKPOINT, mmr_proof, or cap_token encodings
	3.	A hub’s v0.0.1+ behavior (FED1, AUTH1, KEX1+, SH1+, LCLASS0, META0+) can be:
	•	configured and inspected using CLI only, and
	•	validated end-to-end via veen selftest plus.
	4.	For any label in a federated deployment:
	•	Its authority, classification, schemas, and lifecycle policies can be recovered and inspected using only VEEN logs and CLI tooling, without any external state.
