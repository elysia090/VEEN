Verifiable End-to-End Network (VEEN) v0.0.1 - Core plus Operational and Upper-Layer Profiles (wire format unchanged)
	0.	Scope

Endpoints hold semantics and cryptography; the hub provides ordering and reachability only. Accepted messages yield signed receipts and are committed into an append-only Merkle Mountain Range (MMR) with logarithmic inclusion proofs. Authority is carried by portable capability tokens. Transport is abstract (HTTP, QUIC, NATS, file). This document restates the immutable v0.0.1 core succinctly and adds operational and upper-layer profiles that do not modify the wire format. Sections 5 to 8 define the v0.0.1 wire objects and proof format. All later sections are additive and do not change bytes on the wire.
	1.	Notation

Byte concatenation is ||. u64be(n) is the 8-byte big-endian encoding of n. u32be(n) is the 4-byte big-endian encoding of n. Trunc_24(x) is the first 24 bytes of x. H is SHA-256. HKDF is HKDF-SHA256. AEAD is XChaCha20-Poly1305 (24-byte nonce). Ed25519 is used for signatures; X25519 for Diffie-Hellman (DH). HPKE is RFC 9180 base mode: KEM X25519HKDF-SHA256, KDF HKDF-SHA256, AEAD ChaCha20-Poly1305, exporter interface is used. Ht(tag, x) = H(ascii(tag) || 0x00 || x). Deterministic CBOR: maps with the exact field order listed in this document; minimal-length unsigned integers; definite-length arrays and byte strings only; no floats; no CBOR tags; fixed-length bstr fields are exact size; unknown keys are rejected.
	2.	Cryptographic profile

profile = {
aead: “xchacha20poly1305”,
kdf: “hkdf-sha256”,
sig: “ed25519”,
dh: “x25519”,
hpke_suite: “X25519-HKDF-SHA256-CHACHA20POLY1305”,
epoch_sec: 60,
pad_block: 0,
mmr_hash: “sha256”
}

profile_id = Ht(“veen/profile”, CBOR(profile))

Every MSG carries profile_id; receivers MAY reject unknown profile_id. Changing any field in profile changes profile_id. All participants in a deployment MUST agree on a single profile_id or an explicit set of supported profile_id values.
	3.	Keys and identities

Clients hold long-term keys id_sign (Ed25519) and id_dh (X25519). Prekeys are X25519 public keys signed by id_sign.

client_id in MSG is an Ed25519 public key that verifies MSG.sig. Clients SHOULD rotate client_id at least once per epoch when epoch_sec > 0, else after at most M messages (RECOMMENDED M = 256). Long-term identity, if needed, is referenced inside payload via cap_ref, never in plaintext MSG fields.

hub_pk is the hub Ed25519 public key and is distributed out of band. Clients and auditors SHOULD pin hub_pk (for example in application configuration or a trust store).
	4.	Streams and labels

stream_id is 32 bytes (for example, H(application name) or some other application-defined identifier).

Let epoch_sec be taken from profile. For a given Unix time t (seconds since Unix epoch):
	•	If epoch_sec > 0, define epoch E = floor(t / epoch_sec).
	•	If epoch_sec == 0, define E = 0.

Define:

label = Ht(“veen/label”, routing_key || stream_id || u64be(E))

where routing_key is a deployment-specific secret or pseudorandom value used to hide routing structure from the hub. The hub orders by label and does not learn stream_id or routing_key.

Receivers SHOULD accept labels where the embedded epoch E is in the inclusive range [E_local - CLOCK_SKEW_EPOCHS, E_local + CLOCK_SKEW_EPOCHS], where E_local is the receiver’s own computed epoch at acceptance time and CLOCK_SKEW_EPOCHS is a deployment parameter (see section 19). Messages with epochs outside this window SHOULD yield E.TIME.

Each label defines an independent, totally ordered stream at the hub. For a given label, the hub maintains a per-label sequence counter stream_seq (see sections 5 and 7).
	5.	Wire objects (immutable core)

The following CBOR objects define the v0.0.1 wire format. Map key order is fixed exactly as listed.

MSG fields (in order):
	•	ver: uint (MUST be 1)
	•	profile_id: bstr(32)
	•	label: bstr(32)
	•	client_id: bstr(32) (Ed25519 public key)
	•	client_seq: uint (per (label, client_id), strictly increasing by exactly 1; see invariants)
	•	prev_ack: uint
	•	auth_ref: bstr(32)? (optional)
	•	ct_hash: bstr(32)
	•	ciphertext: bstr
	•	sig: bstr(64) (Ed25519 signature over Ht(“veen/sig”, CBOR(MSG without sig)))

Ciphertext formation:
	1.	(enc, ctx) = HPKE.SealSetup(pkR) where pkR is the receiver HPKE public key (for example derived from a prekey).
	2.	hpke_ct_hdr = HPKE.Seal(ctx, “”, CBOR(payload_hdr)).
	3.	k_body = HPKE.Export(ctx, “veen/body-k”, 32).
	4.	nonce = Trunc_24(Ht(“veen/nonce”, label || u64be(prev_ack) || client_id || u64be(client_seq))).
	5.	aead_ct_body = AEAD_Encrypt(k_body, nonce, “”, body).
	6.	hdr_len = u32be(len(hpke_ct_hdr)).
	7.	body_len = u32be(len(aead_ct_body)).
	8.	ciphertext = enc || hdr_len || body_len || hpke_ct_hdr || aead_ct_body.
	9.	If pad_block > 0, right-pad ciphertext with zero bytes so that len(ciphertext) is a multiple of pad_block. Receivers MUST treat padding bytes as unauthenticated zeros and MUST strip them before AEAD_Decrypt.
	10.	ct_hash = H(ciphertext).
	11.	leaf_hash = Ht(“veen/leaf”, label || profile_id || ct_hash || client_id || u64be(client_seq)).
	12.	msg_id = leaf_hash.

RECEIPT fields (in order):
	•	ver: uint (MUST be 1)
	•	label: bstr(32)
	•	stream_seq: uint
	•	leaf_hash: bstr(32)
	•	mmr_root: bstr(32)
	•	hub_ts: uint (hub-local Unix time seconds at commit)
	•	hub_sig: bstr(64) (Ed25519 signature over Ht(“veen/sig”, CBOR(RECEIPT without hub_sig)))

CHECKPOINT fields (in order):
	•	ver: uint (MUST be 1)
	•	label_prev: bstr(32)
	•	label_curr: bstr(32)
	•	upto_seq: uint
	•	mmr_root: bstr(32)
	•	epoch: uint
	•	hub_sig: bstr(64)
	•	witness_sigs: [bstr(64)]? (optional)

For each label, stream_seq is defined as the number of accepted messages (leaves) for that label. The first accepted MSG under a label has stream_seq = 1, the second has stream_seq = 2, and so on. This stream_seq is the MMR leaf index used for that label (see section 7).
	6.	Payload header (encrypted, hub-blind)

CBOR(payload_hdr) is the first item inside the ciphertext and is AEAD-authenticated. payload_hdr is HPKE-encrypted as hpke_ct_hdr and is length-delimited by hdr_len (section 5); aead_ct_body is length-delimited by body_len. Fields (in order):
	•	schema: bstr(32) (application-defined schema identifier)
	•	parent_id: bstr(32)? (optional, parent msg_id)
	•	att_root: bstr(32)? (optional attachment Merkle root; see section 10)
	•	cap_ref: bstr(32)? (optional reference to a capability token; see section 11)
	•	expires_at: uint? (optional Unix time seconds for application-level expiry)

The hub never sees payload_hdr in plaintext.
	7.	Hub commitment (MMR)

For each label, the hub maintains an MMR state (seq, peaks) where seq is the number of accepted leaves (equal to stream_seq for the last accepted message) and peaks is the list of current peak hashes ordered by increasing tree size.

Append x (where x is leaf_hash for the new MSG):
	1.	seq += 1
	2.	Treat x as a leaf. While the least significant bit of seq is 0, fold:
node = Ht(“veen/mmr-node”, left || right)
where left and right are the last two consecutive subtrees. Replace them with node and shift to the next bit.
	3.	After all folds, peaks contains one hash per peak. Compute:
	•	If there is a single peak p, mmr_root = p.
	•	If there are multiple peaks [p1, …, pk] ordered by increasing tree size:
mmr_root = Ht(“veen/mmr-root”, p1 || … || pk).
	4.	Emit a RECEIPT with this mmr_root and stream_seq = seq.

By definition, for each RECEIPT, mmr_root is the MMR root that results from appending leaf_hash at position stream_seq under that label.
	8.	Inclusion proof

mmr_proof is a CBOR map:

{
ver: uint (MUST be 1),
leaf_hash: bstr(32),
path: [ { dir: 0|1, sib: bstr(32) }, … ],
peaks_after: [ bstr(32), … ]
}

Verification folds leaf_hash and path according to dir (0 for left, 1 for right) using Ht(“veen/mmr-node”, left || right) to reconstruct the relevant peak, and then folds peaks_after using Ht(“veen/mmr-root”, …) to yield mmr_root. The verifier checks that this mmr_root matches the mmr_root in some RECEIPT or CHECKPOINT.
	9.	Client algorithms

Send:
	1.	Build payload_hdr and attachments (if any), compute att_root if needed (section 10).
	2.	Form ciphertext and ct_hash as in section 5.
	3.	Construct MSG with fields set according to section 5; compute sig over Ht(“veen/sig”, CBOR(MSG without sig)).
	4.	Submit MSG via submit API (section 16).
	5.	On RECEIPT:
	•	Verify hub_sig using hub_pk.
	•	Check invariants I1..I12.
	•	Advance local MMR for this label to match mmr_root and stream_seq.
	•	Set prev_ack = stream_seq for subsequent MSG under the same label.
	•	Rekey per receipt s: rk_next = HKDF(rk, “veen/rk” || u64be(s)) and derive send/recv keys from rk_next.
	•	Refresh HPKE (new ctx, new enc) at least once per epoch and RECOMMENDED every M messages per (label, client_id), where M is implementation-defined (for example M = 256).

Receive:
	1.	Receive a pair (RECEIPT, MSG) from stream (section 16).
	2.	Verify hub_sig and invariants I1..I12.
	3.	Update local MMR for the label to match mmr_root and stream_seq, validating any provided mmr_proof if with_proof was requested.
	4.	Decrypt:
	•	Split ciphertext into enc (HPKE encapsulated key), hdr_len, body_len, hpke_ct_hdr, and aead_ct_body as in section 5. If pad_block > 0, verify any trailing padding bytes are zero and strip them after parsing the length-delimited header/body.
	•	Use HPKE.Open with enc to recover payload_hdr, and derive k_body via HPKE.Export(ctx, “veen/body-k”, 32). If ctx is not cached, reconstruct it via HPKE.SetupBaseR with enc and the receiver private key.
	•	Recompute nonce as in section 5.
	•	AEAD_Decrypt with k_body, nonce, and associated data “” to recover body.
	5.	Deliver decrypted payload to the application if all checks pass.
	6.	Accept epochs E in [E_local - CLOCK_SKEW_EPOCHS, E_local + CLOCK_SKEW_EPOCHS] for labels.

Failure to progress prev_ack across R attempts (RECOMMENDED R = 3) SHOULD trigger HPKE refresh and prekey fetch as per RESYNC0 (section 23).
	10.	Attachments

For attachment i (0-based or 1-based index, implementation MUST choose one convention and apply it consistently):
	1.	k_att = HPKE.Export(ctx, “veen/att-k” || u64be(i), 32).
	2.	n_att = Trunc_24(Ht(“veen/att-nonce”, msg_id || u64be(i))).
	3.	c = AEAD_Encrypt(k_att, n_att, “”, b) where b is the attachment plaintext.
	4.	coid = H(c).

att_root is a Merkle root over the ordered list of coids (sorted by attachment index i ascending) with:
	•	Internal node: Ht(“veen/att-node”, left || right)
	•	Root: Ht(“veen/att-root”, peak1 || …)

where peaks are ordered and combined similarly to section 7.

att_root is placed into payload_hdr.att_root. Verification requires recomputing the ordered coid list and the Merkle root and checking equality with att_root.
	11.	Capability tokens and admission

cap_token is a CBOR map:

{
ver: 1,
issuer_pk: bstr(32),
subject_pk: bstr(32),
allow: {
stream_ids: [ bstr(32), … ],
ttl: uint,
rate: { per_sec: uint, burst: uint }?
},
sig_chain: [ bstr(64), … ]
}

Each link in sig_chain is an Ed25519 signature over:

Ht(“veen/cap-link”, issuer_pk || subject_pk || CBOR(allow) || prev_link_hash)

where prev_link_hash is a 32-byte value:
	•	For the root link, prev_link_hash is 32 zero bytes.
	•	For each subsequent link, prev_link_hash is H(previous_signature).

auth_ref is defined as:

auth_ref = Ht(“veen/cap”, CBOR(cap_token))

auth_ref is placed into MSG.auth_ref when the client uses this cap_token.

cap_ref is defined as:

cap_ref = auth_ref

If payload_hdr.cap_ref is present, MSG.auth_ref MUST be present and MUST equal payload_hdr.cap_ref to bind the encrypted payload to the same capability used for admission.

Hubs MUST, at admission time, verify every signature in sig_chain back to the root (prev_link_hash = zeros). Any verification failure yields E.CAP. Hubs MAY cache validated cap_tokens keyed by auth_ref for performance.

Hubs MAY enforce admission via /authorize (section 16). A successful authorization installs an admission record keyed by auth_ref.

Stream scoping note: cap_token.allow.stream_ids refers to the stream_id inputs used to derive labels. Hub-side enforcement of allow.stream_ids requires a deployment-defined stream_id_for_label(label) mapping (for example by sharing routing_key with the hub or providing an out-of-band mapping service). If such a mapping is not available, hubs MUST document that they cannot enforce allow.stream_ids and MUST NOT claim OP0 admission gating for stream scoping; receivers SHOULD enforce stream scoping after decrypt by checking payload_hdr.cap_ref against the expected stream_id policy.
	12.	Invariants (MUST on accepted (RECEIPT, MSG))

For any accepted (MSG, RECEIPT) pair, hubs and clients MUST enforce:

I1. H(ciphertext) = ct_hash.

I2. leaf_hash = Ht(“veen/leaf”, label || profile_id || ct_hash || client_id || u64be(client_seq)).

I3. mmr_root equals the MMR root obtained by appending leaf_hash at position stream_seq in the label’s MMR, starting from an empty MMR at stream_seq = 0 and applying the procedure in section 7.

I4. profile_id is supported by both client and hub.

I5. If att_root exists in payload_hdr, it matches exactly the Merkle root of the ordered coid list for attachments, as defined in section 10.

I6. prev_ack <= last observed stream_seq for the label at the hub at the time of acceptance.

I7. Capability constraints via auth_ref (on the hub) and cap_ref (inside the payload) hold at acceptance. This includes:
	•	ttl not expired,
	•	allowed stream_ids containing the label’s stream_id, and
	•	rate limits not exceeded (see OP0.2 and OP0.3).
Hub enforcement covers auth_ref, ttl, rate limits, and any stream_id policy only if stream_id_for_label(label) is available. Receiver enforcement covers payload_hdr.cap_ref (if present) and any application-level stream_id policy.

I8. Within a label, (client_id, client_seq) is unique across all accepted MSG.

I9. For a fixed (label, client_id), client_seq increases by exactly 1 per accepted MSG under that label.

I10. CBOR determinism is respected for all VEEN wire objects:
	•	exact keys and order as listed in this document,
	•	minimal unsigned integers,
	•	exact bstr sizes where specified,
	•	no unknown keys.

I11. AEAD nonce uniqueness: For any fixed profile_id, label, client_id, and HPKE context (ctx) used to derive k_body, the pair (prev_ack, client_seq) used in MSG MUST NOT repeat across accepted messages. As a consequence, the nonce computed as Trunc_24(Ht(“veen/nonce”, label || u64be(prev_ack) || client_id || u64be(client_seq))) is unique per k_body and AEAD key, and AEAD_Encrypt is never invoked with the same (key, nonce) pair twice.

I12. MMR index consistency: For each label, stream_seq in RECEIPT is equal to the MMR leaf index of leaf_hash for that label (1-based). The label’s MMR seq counter and stream_seq MUST match and MUST be contiguous with no gaps.
	13.	Errors

Error codes are ASCII text at the CBOR layer:
	•	E.SIG    (signature failure, including hub_sig or MSG.sig)
	•	E.SIZE   (bounds violation, including MAX_* limits)
	•	E.SEQ    (sequence invariant violation, including I6, I8, I9, I12)
	•	E.CAP    (capability failure, including invalid sig_chain, expired ttl)
	•	E.AUTH   (missing or invalid authorization record)
	•	E.RATE   (rate limit exceeded)
	•	E.PROFILE (unsupported profile_id)
	•	E.DUP    (duplicate leaf or message)
	•	E.TIME   (epoch or time-related failure)

Response body is CBOR:

{ code: “E.*”, detail: text? }

Hubs MAY include additional structured fields in detail for diagnostics, but clients MUST treat them as informational only.
	14.	Security properties (informal)

	•	End-to-end confidentiality is provided by HPKE plus AEAD.
	•	Authenticity and integrity of MSG and RECEIPT are provided by Ed25519 signatures.
	•	Append-only properties for accepted messages are provided by MMR receipts and CHECKPOINTs.
	•	Public equivocation proofs are possible by presenting two RECEIPTs with identical (label, stream_seq) and different mmr_root or leaf_hash.
	•	Routing privacy is provided by pseudorandom labels and client_id rotation; the hub does not see stream_id or routing_key in plaintext.
	•	Cross-stream replay is prevented because leaf_hash binds ct_hash to (label, profile_id, client_id, client_seq).
	•	Nonce uniqueness for AEAD is guaranteed by I8, I9, and I11.
	•	Length-hiding is provided by pad_block; ciphertext length is padded and included in ct_hash.

	15.	Portability

Portable WORM (write-once read-many) set:
	•	identity_card(pub) (client public identity data)
	•	keystore.enc (encrypted key material)
	•	routing_secret (secret used to derive routing_key)
	•	receipts.cborseq (append-only CBOR Sequence of RECEIPT)
	•	checkpoints.cborseq (append-only CBOR Sequence of CHECKPOINT)
	•	payloads.cborseq (append-only CBOR Sequence of MSG payloads, if stored)
	•	sync_state = { last_stream_seq, last_mmr_root } per label
	•	cap_tokens (set of cap_token objects)
	•	optional attachments, addressed by coid

CBOR Sequence is as in RFC 8742.
	16.	API surface (transport-agnostic)

submit:
	•	Request: POST CBOR(MSG)
	•	Response: CBOR(RECEIPT)
	•	Errors: CBOR({ code: “E.*”, detail?: text })

stream:
	•	Request: GET with parameters label, from=stream_seq, with_proof=bool?
	•	Response: CBOR Sequence of items:
{ RECEIPT, MSG, mmr_proof? }

where mmr_proof is present only if with_proof=1.

checkpoint_latest:
	•	Request: GET label
	•	Response: CHECKPOINT

checkpoint_range:
	•	Request: GET epoch range [epoch_min, epoch_max]
	•	Response: CBOR Sequence of CHECKPOINT

authorize:
	•	Request: POST CBOR(cap_token)
	•	Response: { auth_ref: bstr(32), expires_at: uint }

report_equivocation:
	•	Request: POST two RECEIPT with identical (label, stream_seq) and differing leaf_hash or mmr_root
	•	Response: { ok: bool }

Implementations MUST treat all endpoints as transport-agnostic; mappings for HTTP, QUIC, and NATS are defined in section 30.
	17.	Complexity

Hub append per MSG:
	•	Time: amortized O(1).
	•	Memory: O(log N) per label for peaks.

Inclusion proofs:
	•	Proof size: O(log N).
	•	Verification: O(log N) hash operations.

Client hot paths (per accepted MSG):
	•	O(1) for local state updates, plus O(log N) if verifying proofs.
	•	Cryptographic operations: O(1) per MSG (HPKE, AEAD, Ed25519).

	18.	Interop discipline

All implementations that claim compliance MUST adhere to:
	•	Exact map key order as listed in this document.
	•	Unknown keys rejected in all VEEN maps.
	•	Minimal unsigned integers.
	•	Exact-size bstr for fixed-size fields (32, 64 bytes, etc).
	•	peaks in MMR and attachments Merkle root ordered by increasing tree size.
	•	Tag prefix “veen/” for all Ht domain separation tags.
	•	Padding bytes included in ct_hash; ciphertext is hashed after padding.
	•	Hubs sign RECEIPT after updating MMR.
	•	Clients verify hub_sig before attempting decryption.

	19.	Limits (defaults, configurable)

The following limits are defaults and MAY be tuned per deployment, but MUST be bounded:
	•	MAX_MSG_BYTES = 1_048_576
	•	MAX_BODY_BYTES = 1_048_320
	•	MAX_HDR_BYTES = 16_384
	•	MAX_PROOF_LEN = 64
	•	MAX_CAP_CHAIN = 8
	•	MAX_ATTACHMENTS_PER_MSG = 1024
	•	CLOCK_SKEW_EPOCHS = 1

Exceeding any bound yields E.SIZE. Implementations SHOULD document any deviations from these default values.
	20.	Conformance vectors

Test vectors and scenarios:
	•	A: single writer per label; basic append-only correctness.
	•	B: multi-writer with (client_id, client_seq) uniqueness and replay prevention.
	•	C: epoch roll and CHECKPOINT chaining correctness across time windows.
	•	D: capability admission via authorize, including sig_chain and rate limiting.

	21.	Operational Profile OP0 (normative, no wire changes)

OP0.1 Processing order (hub):

For each submit request:
	1.	Decode CBOR(MSG); on failure or truncation, return E.SIZE.
	2.	Check bounds (MAX_MSG_BYTES, MAX_HDR_BYTES, etc); on violation, return E.SIZE.
	3.	Verify MSG.sig; on failure, return E.SIG.
	4.	If admission is configured, authorize via auth_ref (section 11); otherwise skip:
	•	Missing admission record: E.AUTH.
	•	Capability failure: E.CAP.
	•	Rate overflow: E.RATE.
	5.	Append leaf_hash to the label’s MMR, update stream_seq and mmr_root, enforcing invariants I1..I12. On violation, return E.SEQ, E.DUP, or E.PROFILE as appropriate.
	6.	Sign RECEIPT (hub_sig).
	7.	Respond with RECEIPT.

On HTTP, hubs SHOULD map error codes as:
	•	E.SIZE -> 413 Payload Too Large
	•	E.RATE -> 429 Too Many Requests
	•	E.AUTH, E.CAP -> 403 Forbidden
	•	E.PROFILE, E.TIME -> 400 Bad Request
	•	E.SIG, E.SEQ, E.DUP -> 409 Conflict

OP0.2 Admission gating:

Hubs SHOULD require /authorize for write access. The authorization record keyed by auth_ref contains:
	•	allowed_stream_ids: set of stream_id values
	•	rate: { per_sec, burst }
	•	expiry: Unix time seconds
	•	subject_pk: expected subject public key

Missing record yields E.AUTH. Expired record yields E.CAP. Rate overflow yields E.RATE.

If the hub cannot derive stream_id from label (for example because routing_key is not shared with the hub), it MUST document that allowed_stream_ids are not enforced at admission time and MUST NOT represent itself as enforcing stream scoping under OP0.2.

OP0.3 Rate limiting RL0:

Token bucket per (auth_ref, label) and optionally per IP address. Each accepted MSG (i.e., each RECEIPT) consumes 1 token. Refill every 1 s by per_sec up to burst. Servers SHOULD emit Retry-After header (seconds) on E.RATE when using HTTP.

OP0.4 Worker pools:

Hubs SHOULD use separate worker pools for:
	•	verification: MSG.sig, cap_token signature chains, basic CBOR checks;
	•	commitment: MMR append, fsync, checkpointing.

Under sustained overload, hubs SHOULD apply back-pressure by returning 503 Service Unavailable when the verification queue exceeds a configured limit Qmax.

OP0.5 Storage:

Hubs SHOULD store:
	•	receipts.cborseq: append-only file of RECEIPT.
	•	payloads.cborseq: append-only file of MSG payloads, if retention for payloads is enabled.
	•	checkpoints.cborseq: append-only file of CHECKPOINT.

fsync policy: sync every N = 100 receipts or T = 100 ms, whichever comes first. Peaks SHOULD be checkpointed every K appends per label to allow fast restart.

OP0.6 Padding policy:

pad_block is in {0, 256, 1024}. Default:
	•	pad_block = 256 for messaging use cases.
	•	pad_block = 0 for bulk ingest where length-hiding is not required.

Padding bytes are zeros and are included in ct_hash.

OP0.7 Clock discipline:

hub_ts is informational and SHOULD reflect hub’s best-effort Unix time seconds. Acceptance windows use CLOCK_SKEW_EPOCHS as in section 4. Large drift relative to clients SHOULD cause E.TIME and SHOULD be surfaced via metrics and alerts.
	22.	Key Distribution Profile KEX0 (normative optional)

KEX0.1 Hub key pin:

Applications ship hub_pk out of band (configuration file, static bundle, etc). For hub key rotation, a rotation window W is defined. During W:
	•	CHECKPOINT objects carry witness_sigs from both old and new hub keys.
	•	Clients that pin hub_pk SHOULD accept CHECKPOINT only if both witness_sigs are present and valid.

After W, the old key is retired and CHECKPOINT no longer carries its signatures.

KEX0.2 Client identity rotation:

client_id rotates at least once per epoch. Key continuity (linking old and new client_id) is tracked locally and MUST NOT be exposed in plaintext MSG fields. Prekeys are signed by id_sign and MUST include expiry times. Hubs SHOULD reject expired prekeys or use them only for decryption of older messages.

KEX0.3 Revocation:

Hubs MAY blacklist client_id or auth_ref. Subsequent submit operations from blacklisted identities return E.CAP or E.AUTH. Blacklist entries SHOULD have expiry times or require manual clearing. Revocation state MAY be distributed via an out-of-band channel.
	23.	Resynchronization and Recovery RESYNC0

RESYNC0.1 Duplicate detection:

Hubs maintain a Bloom filter plus LRU cache of recent leaf_hash values for a configurable window Wdup. A repeat leaf_hash in this window yields E.DUP. The authoritative duplicate check remains the label’s accepted set defined by I8 and I12.

RESYNC0.2 Client resync:

Clients that lose connection or suspect divergence:
	1.	Reconnect with stream?from=last_stream_seq+1.
	2.	Verify hub_sig and invariants I1..I12 for each RECEIPT and MSG.
	3.	If mmr_root or proofs diverge from local state, request checkpoint_latest for the label, rebuild local peaks from CHECKPOINT, and then replay receipts from an earlier stream_seq as needed.

RESYNC0.3 Rekey:

If prev_ack fails to progress across R consecutive attempts for a given label (RECOMMENDED R = 3):
	•	Client refreshes HPKE ctx (new prekey, new HPKE key exchange).
	•	Client MAY fetch a fresh prekey set or update its own id_dh/id_sign.

RESYNC0.4 Durable state:

Clients SHOULD persist, per label:
	•	rk (current rekey material),
	•	current profile_id,
	•	last_stream_seq,
	•	last_mmr_root.

These values MUST be persisted atomically so that after a crash, resync uses a consistent snapshot.
	24.	RPC Overlay RPC0 (pure overlay, no wire changes)

RPC0.1 Request message:
	•	payload_hdr.schema = H(“rpc.v1”)
	•	payload body:
{
method: text,
args: CBOR,
timeout_ms: uint?,
reply_to: bstr(32)?
}

msg_id acts as the correlation id. Servers reply with parent_id = msg_id in the reply payload_hdr.

RPC0.2 Reply message:
	•	payload_hdr.schema = H(“rpc.res.v1”)
	•	payload body:
{
ok: bool,
result: CBOR?,
error: { code: text, detail: text? }?
}

If ok = true, result MUST be present and error MUST be absent. If ok = false, error MUST be present.

RPC0.3 Idempotency:

Clients MAY set body.idem: uint64 as an idempotency key. Servers MUST treat (method, client_id, idem) as an idempotency key, ensuring that duplicate requests with the same tuple have the same effect and return the same logical result.

RPC0.4 Timeouts and retries:

Clients SHOULD use application-level timeouts and exponential backoff when retrying. Duplicate requests are harmless due to E.DUP and idempotency keys.
	25.	CRDT Overlay CRDT0 (pure overlay)

CRDT0.1 LWW-Register:
	•	schema = H(“crdt.lww.v1”)
	•	body:
{ key: bytes, ts: uint64, value: bytes }

Total order by (ts, stream_seq) breaks ties. Application clocks are optional. Last writer wins based on this total order.

CRDT0.2 OR-Set:
	•	schema = H(“crdt.orset.v1”)
	•	add operation body: { id: bstr(32), elem: bytes }
	•	remove operation body: { tomb: [ bstr(32), … ] }

Concurrency is resolved by element presence: an element is present if there exists an add id that is not listed in any tomb set in the prefix considered.

CRDT0.3 Counter G-Counter:
	•	schema = H(“crdt.gcnt.v1”)
	•	body: { shard: bstr(32), delta: uint64 }

Reduction is sum of deltas per shard. Snapshots are deterministic folds of receipts up to upto_seq in CHECKPOINT.

CRDT0.4 Provenance:

att_root commits any large element payloads. Verification requires recomputing the coid set from attachment ciphertexts and checking att_root.
	26.	Anchoring and Bridging ANCHOR0 (pure overlay)

ANCHOR0.1 External anchor interface:
	•	anchor_publish(root: bstr(32), epoch: uint, ts: uint, nonce: bytes) -> anchor_ref: bytes
	•	anchor_verify(root: bstr(32), anchor_ref: bytes) -> bool

Implementations map these operations to a ledger or anchoring system of choice (public blockchain, internal audit log, etc).

ANCHOR0.2 Policy:

Hubs SHOULD anchor mmr_root at a fixed cadence, for example:
	•	every K receipts per label, or
	•	every T minutes per deployment.

anchor_ref MUST be stored alongside CHECKPOINT so that auditors can recover the binding from mmr_root to external ledger.

ANCHOR0.3 Cross-hub mirroring:

A bridge process subscribes to stream(with_proof=1) on hub A and submits those MSG to hub B under label’ with a distinct routing_key’. RECEIPTs from B include a new leaf_hash and mmr_root. Provenance is preserved by embedding parent_id = original msg_id in the mirrored payload_hdr.
	27.	Observability OBS0

OBS0.1 Metrics (names and units):
	•	veen_submit_ok_total (counter)
	•	veen_submit_err_total{code} (counter)
	•	veen_verify_latency_ms (histogram)
	•	veen_commit_latency_ms (histogram)
	•	veen_end_to_end_latency_ms (histogram)
	•	veen_queue_depth (gauge)
	•	veen_rate_limited_total (counter)
	•	veen_checkpoint_interval (histogram)
	•	veen_anchor_fail_total (counter)

OBS0.2 Logs:

Structured JSON per submit with fields:
	•	label
	•	client_id_prefix (for example first 8 hex chars)
	•	stream_seq
	•	leaf_hash_prefix
	•	code? (error code if any)
	•	bytes_in
	•	bytes_out
	•	verify_ms
	•	commit_ms

OBS0.3 Health:

/healthz returns:

{
ok: bool,
profile_id: bstr(32),
peaks_count: uint,
last_stream_seq: uint,
last_mmr_root: bstr(32)
}
	28.	Compliance and Retention COMP0

COMP0.1 Retention:
	•	receipts.cborseq retained for Rr days.
	•	payloads.cborseq retained for Rp days if payload retention is enabled.
	•	checkpoints.cborseq retained indefinitely or as long as needed for audit plus external anchoring.

File rotation MAY be by size or time. An index sidecar per rotated file stores:

{ offset: uint64, stream_seq: uint64 }

to allow random access.

COMP0.2 Encryption at rest:
	•	keystore.enc MAY be sealed with OS KMS or hardware security modules.
	•	payloads and receipts MAY be whole-file AEAD-encrypted at rest. This is orthogonal to the on-wire protocol and MUST NOT change wire formats.

COMP0.3 Access:

Read-only export endpoints:
	•	stream?with_proof=1 for auditors.

These endpoints SHOULD be rate-limited and MAY require signed URLs or mutual TLS.
	29.	Security Hardening SH0

SH0.1 Prefilter:

During overload, hubs MAY require a stateless cookie (QUIC-token-like) or proof-of-work salt before performing signature verification. Failure to provide such a cookie yields HTTP 403 or 429 depending on deployment policy.

SH0.2 Constant-time checks:
	•	Ed25519 verify MUST be constant-time.
	•	String/bytes comparisons on auth_ref MUST use constant-time equality to avoid timing leaks.

SH0.3 TLS:

When using TLS, hubs MUST:
	•	use modern AEAD cipher suites,
	•	disable TLS-level compression.

SH0.4 Bounds first:

All size and bounds checks MUST be performed before performing costly signature or HPKE work, to avoid waste under attack or abuse.
	30.	Deployment Reference DR0

HTTP:
	•	Content-Type application/cbor for all POST bodies.
	•	stream endpoint returns Content-Type application/cbor-seq.

QUIC:
	•	Map endpoints 1:1 with HTTP-like semantics over QUIC streams.
	•	Use TLS as in SH0.3.

NATS:
	•	Subjects:
	•	submit.<label_hex> for MSG submissions.
	•	Replies carry RECEIPT as CBOR in the reply payload.

	31.	Test Suite TS0

TS0.1 Unit tests:
	•	Conformance vectors A to D for basic flows.
	•	CBOR determinism for MSG, RECEIPT, CHECKPOINT, mmr_proof, cap_token.
	•	Nonce uniqueness for AEAD under repeated sends.

TS0.2 Property tests:
	•	MMR associativity and idempotence of append operations.
	•	Proof minimality for mmr_proof.
	•	Duplicate rejection according to I8 and I12.

TS0.3 Fuzz tests:
	•	Malformed CBOR maps (unknown keys, overlong integers, indefinite lengths).
	•	Truncated ciphertext, receipts, and checkpoints.

TS0.4 Interop tests:
	•	Cross-implementation exchange of vectors A to D.
	•	Byte-for-byte equality on MSG and RECEIPT encodings.
	•	Identical mmr_root for identical sequences of leaf_hash values.

	32.	Reference state machines (informative)

Hub RX:
	•	Idle
-> DecodeOK? else E.SIZE
-> BoundsOK? else E.SIZE
-> SigOK? else E.SIG
-> Authorized? else E.AUTH / E.CAP / E.RATE
-> Commit (MMR append, invariants I1..I12) else E.SEQ / E.DUP / E.PROFILE
-> Sign RECEIPT
-> Respond.

Client TX:
	•	Build MSG
-> HPKE / AEAD
-> Sign
-> Submit
-> ReceiptOK? else retry with backoff or resync
-> Verify + Advance local MMR
-> Done.

Client RX:
	•	ReceiptOK? else drop
-> Verify root / proof
-> Decrypt
-> Deliver to application.

	33.	Compatibility

All OP0, KEX0, RESYNC0, RPC0, CRDT0, ANCHOR0, OBS0, COMP0, SH0, DR0, and TS0 clauses are additive and do not change the v0.0.1 wire format defined in sections 5 to 8. Implementations MAY claim:
	•	“VEEN v0.0.1 Core”
	•	“VEEN v0.0.1 Core + OP0”
	•	“VEEN v0.0.1 Core + OP0 + RPC0 + CRDT0”
	•	or similar, depending on which profiles are implemented.

An implementation that implements only Core MUST still obey all invariants I1..I12 and the CBOR and MMR rules in sections 5 to 8.
	34.	Summary

This document consolidates the VEEN v0.0.1 core with a fixed wire format and specifies operational edges (admission, rate limiting, rotation, recovery) plus portable overlays for RPC, CRDTs, external anchoring, observability, compliance, and hardening. A compliant “Core + OP0” hub and client can be deployed for end-to-end encrypted, verifiable messaging and audit logging immediately; overlays can be enabled incrementally without re-encoding messages or changing bytes on the wire.
