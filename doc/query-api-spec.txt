Query API Specification v0.0.1 (Tightened)
	0.	Scope

This document tightens the Query API on top of a VEEN deployment that already implements:
	•	Server Drive Recorder profile
	•	Air-gap Bridge profile

The Query API:
	1.	Treats queries and results as first-class recorder events.
	2.	Provides deterministic, verifiable digests for returned result sets.
	3.	Allows reconstruction and replay of queries across zones.

No new cryptography is introduced. The API is a structured way to:
	•	express queries,
	•	record them as events,
	•	produce and verify results.

	1.	Terminology

hub: VEEN-compatible message hub.
stream: named ordered stream of VEEN messages.
event: application-level payload plus metadata in a VEEN message.
receipt: cryptographically verifiable record of a committed VEEN message.
checkpoint: compact snapshot: log root + stream positions + metadata.
trust domain: set of systems under a shared security policy.
zone: concrete deployment region (e.g. online zone, offline zone).
query: structured request for a derived view of recorder events.
QueryDescriptor: canonical JSON representation of a query.
ResultRow: single row of a query result.
ResultDigest: compact summary and hash of a result set.
evidence: cryptographic material to verify that result rows match underlying events.
principal: VEEN client identity (key) that submits a query.
	2.	Namespaces and resources

2.1. Streams

The Query API uses the following recorder streams:
	1.	Query request stream
	•	Name: record/query/requests
	•	Direction: append-only
	•	Payload: normalized QueryDescriptor
	2.	Query result stream
	•	Name: record/query/results
	•	Direction: append-only
	•	Payload: ResultDigest
	3.	Optional query audit streams
	•	Name: record/query/audit/*
	•	Direction: append-only
	•	Payload: implementation-specific execution logs

All streams inherit the guarantees of the underlying Recorder profile: signed messages, inclusion in an append-only log, and MMR-based proofs.

2.2. Identifiers

The following identifiers are treated as opaque ASCII strings:

query_id: unique per query submission.
result_id: unique per query execution.
receipt_id: reference to a VEEN receipt for a source event.
hub_id: identifier of a VEEN hub instance.
profile_id: identifier of a hub profile or deployment configuration.

Constraints:
	•	query_id and result_id MUST be unique in the hub.
	•	Implementations MAY use UUIDv4 or cryptographic hashes; the format MUST be stable and documented.

	3.	Data types and encoding

3.1. JSON encoding

All API payloads and stored QueryDescriptor and ResultDigest objects use JSON with:
	1.	UTF-8 encoding.
	2.	No binary blobs; binary data must be hex or base64.
	3.	Deterministic canonicalization for hashing:
	•	object keys sorted lexicographically (byte order),
	•	no insignificant whitespace,
	•	numeric values encoded in minimal decimal form (no leading zeros, no unnecessary trailing zeros),
	•	strings encoded as UTF-8 with standard JSON escaping,
	•	arrays preserve order.

When this document refers to “canonical JSON” it means this encoding.

3.2. Timestamps

All timestamps are ISO-8601 UTC strings:
	•	Format: YYYY-MM-DDTHH:MM:SSZ
	•	Example: 2025-11-19T03:20:00Z

Sub-second precision MAY be added as fractional seconds, but MUST be consistent across implementation (e.g. always millisecond 3 decimal digits).
	4.	QueryDescriptor model

4.1. Shape

A QueryDescriptor is a JSON object:

{
“query_id”: “string”,
“version”: 1,
“scope”: [ “string”, … ],
“filter”: { … },
“projection”: [ “string”, … ],
“aggregate”: { … },   // optional
“evidence”: { … },
“meta”: { … }         // optional
}

4.2. Fields (required core)
	1.	query_id (string)
	•	Globally unique per submitted query.
	•	If not supplied by the client, the server MUST generate it and include it in the normalized descriptor.
	2.	version (integer)
	•	MUST be 1 for this specification.
	3.	scope (array of string)
	•	Non-empty array of stream names.
	•	Each entry SHOULD be a recorder stream (e.g. “record/app/http”).
	•	Implementations MUST reject unknown or unauthorized streams.
	4.	filter (object)
	•	Minimal required fields:
{
“subject_id”: “string or null”,           // optional
“event_type”: [“string”, …] or null,    // optional
“time”: {
“from”: “timestamp or null”,
“to”: “timestamp or null”
}
}
Semantics:
	•	subject_id: include only events with matching subject_id if present.
	•	event_type: include only events whose event_type is in the list.
	•	time.from / time.to: filter by hub_commit_time or event_time (implementation MUST document which).
If a field is omitted or null, it does not constrain the result.
	5.	projection (array of string)
	•	Non-empty.
	•	Each entry names a logical field or path. Minimal required fields:
	•	“subject_id”
	•	“principal_id”
	•	“event_time”
	•	“origin”
	•	“event_type”
	•	“payload.*” (implementation MAY support dotted paths)
	•	“receipt_id” (if available from storage)
If projection is [”*”], implementation MAY return a default field set.
	6.	evidence (object)
	•	Evidence policy:
{
“mode”: “none” | “spot” | “full”,
“sample_rate”: number  // required for “spot”
}
Constraints:
	•	mode “none”: sample_rate MUST be omitted or null.
	•	mode “spot”: sample_rate MUST be in (0, 1].
	•	mode “full”: sample_rate MUST be omitted or null.

4.3. Fields (optional extensions)
	1.	aggregate (object)
	•	Optional; if absent, the query is a row-level selection.
	•	Minimal structure:
{
“group_by”: [“field”, …],      // optional; empty or omitted = no grouping
“metrics”: [
“count”,
“min(event_time)”,
“max(event_time)”
]
}
	•	count MUST be supported; other metrics are implementation-defined.
	2.	meta (object)
	•	Free-form metadata. Recommended keys:
{
“requested_by”: “principal-id or human id”,
“requested_at”: “timestamp”,
“reason”: “string”
}

4.4. Normalization

On submission:
	1.	The server parses the client-supplied descriptor.
	2.	It fills defaults:
	•	set version = 1 if missing,
	•	generate query_id if missing,
	•	normalize filter, projection, evidence, meta to canonical JSON.
	3.	It validates:
	•	required fields are present,
	•	types are correct,
	•	references (streams, metrics, fields) are supported.

If validation fails, the API MUST return HTTP 400 with an error payload (see section 7.4).

The normalized QueryDescriptor is the one stored in record/query/requests.

4.5. Recording as VEEN event

The normalized QueryDescriptor MUST be embedded in a VEEN message:
	•	stream: record/query/requests
	•	body: canonical JSON of the descriptor
	•	recorder layer MUST populate:
	•	subject_id: the actor on whose behalf the query is run,
	•	principal_id: the VEEN client key id,
	•	event_type: “query.submitted” (or equivalent stable string),
	•	event_time: server receive time.

	5.	Result model

5.1. ResultRow

ResultRow is a logical row returned by the query engine. There is no fixed global schema; fields derive from projection and aggregate.

Constraints:
	1.	Each row MUST be representable as a JSON object.
	2.	For selection queries:
	•	it SHOULD include projected base fields (such as subject_id, event_time).
	3.	For aggregate queries:
	•	it SHOULD include group keys and metric values.
	4.	If projection includes “receipt_id”:
	•	each row MUST include a string “receipt_id” that refers to a VEEN receipt for the source event or a canonical derived identifier (implementation MUST document mapping).

Example (selection):

{
“subject_id”: “user:123”,
“event_time”: “2025-11-18T12:34:56Z”,
“origin”: “api-gateway-1”,
“path”: “/login”,
“status”: 401,
“receipt_id”: “rcpt-abc…”
}

Example (aggregate):

{
“subject_id”: “user:123”,
“origin”: “api-gateway-1”,
“count”: 23,
“first_seen”: “2025-11-18T00:10:00Z”,
“last_seen”: “2025-11-18T23:50:00Z”
}

5.2. ResultDigest

ResultDigest has this minimal structure:

{
“query_id”: “q-…”,
“result_id”: “r-…”,
“version”: 1,
“row_count”: 123,
“evidence_policy”: {
“mode”: “spot”,
“sample_rate”: 0.1
},
“rows_hash”: “hex”,
“evidence_hash”: “hex”,
“executed_at”: “timestamp”,
“hub_id”: “hub-…”,
“profile_id”: “profile-…”   // optional
}

Fields:
	•	query_id: MUST match the QueryDescriptor.
	•	result_id: unique; binds the fetchable result to this digest.
	•	version: MUST be 1.
	•	row_count: number of rows after aggregation.
	•	evidence_policy: normalized copy of evidence.
	•	rows_hash: SHA-256 (or stronger) of canonical JSON encoding of the rows array.
	•	evidence_hash: SHA-256 (or stronger) of canonical JSON encoding of evidence summary (see 6).
	•	executed_at: timestamp when the result set was fully materialized.
	•	hub_id: hub identity at execution time.
	•	profile_id: optional; identifies hub configuration profile.

5.3. Canonical rows_hash

To compute rows_hash:
	1.	Construct an array R of ResultRow objects in the order they will be returned to the client.
	2.	Encode R as canonical JSON (section 3.1).
	3.	Compute SHA-256 over the resulting bytes.
	4.	Encode as lowercase hex string.

rows_hash = hex(sha256(canonical_json(R)))

5.4. Canonical evidence_hash

The exact shape of evidence summary is implementation-defined but MUST be deterministic.

Minimal requirement:
	1.	For mode “none”:
	•	evidence_summary := { “mode”: “none” }
	2.	For mode “spot” or “full”:
	•	evidence_summary MUST include at least:
	•	query_id
	•	result_id
	•	mode
	•	sample_rate (for mode “spot”)
	•	a list of verified entries; each entry SHOULD contain:
	•	receipt_id
	•	mmr_root or equivalent
	•	hub_id

Example:

{
“query_id”: “q-…”,
“result_id”: “r-…”,
“mode”: “spot”,
“sample_rate”: 0.1,
“verified”: [
{
“receipt_id”: “rcpt-1”,
“mmr_root”: “hex”,
“hub_id”: “hub-…”
},
{
“receipt_id”: “rcpt-2”,
“mmr_root”: “hex”,
“hub_id”: “hub-…”
}
]
}

evidence_hash is then:

evidence_hash = hex(sha256(canonical_json(evidence_summary)))

5.5. Recording ResultDigest

ResultDigest MUST be embedded in a VEEN message:
	•	stream: record/query/results
	•	body: canonical JSON of the digest
	•	event_type: “query.result”
	•	subject_id: principal or service responsible for execution
	•	principal_id: execution engine identity

	6.	Evidence modes

6.1. Mode “none”
	•	Engine does not resolve receipts.
	•	Engine does not verify MMR or signatures.
	•	rows_hash MUST still be computed.
	•	evidence_summary is minimal; evidence_hash is deterministic.

Use cases:
	•	dashboards,
	•	low-criticality analytics.

6.2. Mode “spot”
	•	Engine must:
	1.	Materialize all ResultRow entries.
	2.	Select a deterministic subset using sample_rate.
	3.	For each sampled row, resolve receipt_id and verify:
	•	signature,
	•	MMR inclusion against a known root.
	4.	Construct evidence_summary with all sampled verifications.
	•	If any sampled verification fails:
	•	the query MUST fail (no successful result is returned).

6.3. Mode “full”
	•	Engine must:
	1.	For every ResultRow, resolve and verify receipts.
	2.	Fail the query if any verification fails.
	3.	Construct evidence_summary that allows recomputation or replay of verification.
	•	Mode “full” is intended for:
	•	forensic investigations,
	•	regulatory-grade reporting.

	7.	HTTP API

7.1. Authentication

All endpoints MUST be protected by:
	•	an authentication layer (e.g. bearer tokens, mTLS), and
	•	a mapping from authenticated principal to VEEN client identity.

Access control rules:
	•	Only authorized principals MAY submit queries.
	•	Access to scopes (streams) MUST be filtered by policy.
	•	Access to results MAY be restricted by:
	•	who submitted the query,
	•	tenant partition,
	•	query classification.

7.2. POST /api/query/submit

Request:
	•	Method: POST
	•	Path: /api/query/submit
	•	Headers:
	•	Content-Type: application/json
	•	Authorization: implementation-defined
	•	Body: JSON, partial or full QueryDescriptor (server can fill query_id and version).

Server behavior:
	1.	Authenticate and authorize.
	2.	Normalize and validate descriptor.
	3.	Emit VEEN event to record/query/requests.
	4.	Schedule execution.
	5.	Allocate result_id.

Response (accepted):

HTTP 202

{
“query_id”: “q-…”,
“result_id”: “r-…”,
“status”: “pending”
}

For small queries, server MAY synchronously execute and respond:

HTTP 200

{
“result_digest”: { … },
“rows”: [ … ]
}

7.3. GET /api/query/status/{result_id}

Optional.
	•	Method: GET
	•	Path: /api/query/status/{result_id}

Response:

HTTP 200

{
“query_id”: “q-…”,
“result_id”: “r-…”,
“status”: “pending” | “running” | “completed” | “failed”,
“error_code”: “string or null”,
“message”: “string or null”
}

7.4. GET /api/query/result/{result_id}

Request:
	•	Method: GET
	•	Path: /api/query/result/{result_id}

Query parameters (optional):
	•	offset: integer, default 0
	•	limit: integer, default 1000, upper bound implementation-defined

Response (completed, paginated):

HTTP 200

{
“result_digest”: { … },         // full digest
“rows”: [ ResultRow, … ],
“page”: {
“offset”: 0,
“limit”: 1000,
“total”: 1234,                  // optional; may be omitted for streaming backends
“has_more”: true | false
}
}

Offset and limit refer to row indices in the logical result set used when computing rows_hash. The server MUST ensure that:
	•	pagination does not change row ordering, and
	•	rows_hash remains the hash of the full ordered result set, not of a single page.

7.5. GET /api/query/descriptor/{query_id}

Optional but recommended for audit.
	•	Method: GET
	•	Path: /api/query/descriptor/{query_id}

Response:

{
“descriptor”: { QueryDescriptor },
“record_event”: {
“stream”: “record/query/requests”,
“seq”: integer,
“hub_id”: “hub-…”,
“receipt_id”: “rcpt-…”
}
}

7.6. Error model

Error responses MUST be JSON:

{
“error_code”: “string”,
“message”: “human readable”
}

Recommended error_code values:
	•	invalid_json
	•	invalid_query_descriptor
	•	unauthorized
	•	forbidden_scope
	•	query_not_found
	•	result_not_ready
	•	execution_failed
	•	internal_error

Mapping to HTTP status:
	•	400: invalid_json, invalid_query_descriptor
	•	401: unauthorized
	•	403: forbidden_scope
	•	404: query_not_found
	•	409: duplicate_query_id
	•	425 or 404 or 409 (implementation-defined): result_not_ready
	•	500: execution_failed, internal_error

	8.	Execution semantics

8.1. State machine (logical)

For each result_id:
	•	PENDING: descriptor accepted, not yet executed.
	•	RUNNING: query engine executing.
	•	COMPLETED: result_digest written to record/query/results and result rows materialized.
	•	FAILED: execution failed; no ResultDigest committed.

Transition rules:
	•	PENDING → RUNNING → COMPLETED
	•	PENDING → RUNNING → FAILED
	•	PENDING → FAILED (fast failure during planning or validation)

Once COMPLETED or FAILED, the state MUST be immutable.

8.2. Coupling with VEEN

A result is considered COMMITTED when:
	1.	ResultDigest event is successfully appended to record/query/results, and
	2.	The hub acknowledges the message and provides a receipt.

The API MAY return the result to the client after the local append but SHOULD expose the receipt or its hash via ResultDigest for later verification.
	9.	Cross-zone usage with Air-gap Bridge

9.1. Query in Z1, replay in Z2

Pattern:
	1.	In zone Z1:
	•	submit query, obtain QueryDescriptor and ResultDigest.
	•	optionally export underlying recorder events via Recorder + Bridge profile.
	2.	Export:
	•	export:
	•	QueryDescriptor event,
	•	ResultDigest event,
	•	the recorder events required by the query (or a superset).
	3.	In zone Z2:
	•	import recorder events.
	•	import QueryDescriptor and ResultDigest as recorder events.
	•	optionally re-run the query engine locally using the imported QueryDescriptor.
	•	compute local ResultDigest’.

If:
	•	QueryDescriptor’ equals QueryDescriptor, and
	•	ResultDigest’ matches ResultDigest on:
	•	query_id
	•	row_count
	•	rows_hash
	•	evidence_hash (for same evidence settings),

then Z2 can assert that:
	•	it observes a recorder history that matches Z1 for the queried scope, up to retention.

9.2. One-way bridge constraints
	•	Queries MAY be submitted separately in each zone.
	•	Query descriptors and digests MAY flow one-way with ordinary exported streams.
	•	No query-related control channel MUST be used to bypass one-way constraints.

	10.	Versioning and compatibility

10.1. Schema versions

This document fixes:
	•	QueryDescriptor.version = 1
	•	ResultDigest.version = 1

If a client supplies another version, the server MUST:
	•	either reject (HTTP 400, error_code = “unsupported_version”), or
	•	explicitly document a migration strategy.

10.2. HTTP API versioning

The bare paths in this document define v0.0.1 behavior. Implementations MAY expose:
	•	/api/v1/query/…

In that case they MUST document which descriptor/result versions the v1 API accepts and produces.

10.3. Backward-compatible extensions

The following are considered backward-compatible:
	•	adding new filter keys that can be safely ignored by older servers,
	•	adding new aggregate metrics that are rejected only if requested,
	•	adding fields to ResultRow and ResultDigest that clients may ignore.

Breaking changes MUST increment the schema version and, if exposed, the HTTP path version.
