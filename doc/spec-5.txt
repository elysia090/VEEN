Discovery Overlay and Connect Application Specification v0.0.1
Plain ASCII, English only. Pure overlay on VEEN v0.0.1; no wire changes.
	0.	Purpose and scope

This document defines a discovery overlay and a connect application that run on top of VEEN v0.0.1. The goal is to let clients:
	•	discover hubs, overlays, and application services available on a VEEN fabric;
	•	query by capability (for example “RPC service implementing method X in region Y”);
	•	obtain connection hints (stream_ids, schemas, capability endpoints) without changing VEEN core.

All semantics are expressed as deterministic folds over discovery streams using normal VEEN messages, RPC0, and optional CRDT0. The wire format (MSG, RECEIPT, CHECKPOINT, cap_token) is unchanged.
	1.	Status

	•	v0.0.1 is an informative but implementation-grade overlay specification.
	•	It is safe to deploy in conjunction with VEEN v0.0.1 Core + OP0 + RPC0.
	•	All behavior is additive; no VEEN core change is required.

	2.	Terms

discovery overlay:
A set of schemas and folding rules used to publish and query descriptors about:
- hubs and their profiles;
- overlays and their streams;
- application services and their RPC endpoints.

discovery hub:
A hub whose operators choose to host one or more discovery streams. Any normal hub MAY act as a discovery hub by dedicating labels to discovery streams.

descriptor:
A CBOR payload describing a hub, overlay, or application (service). Descriptors are log-derived; the overlay never mutates in-place state.

connect application:
A client-side and optional server-side component that:
- issues discovery queries via RPC0;
- folds discovery streams locally;
- proposes connection plans (which hub, which label, which schema) to higher layers.
	3.	High-level design

The discovery overlay introduces:
	•	one or more well-known discovery stream_ids (for example:
	•	disc.hubs.v1
	•	disc.services.v1
	•	disc.overlays.v1 )
	•	a small set of schemas:
	•	disc.hub.advertise.v1
	•	disc.hub.retire.v1
	•	disc.service.advertise.v1
	•	disc.service.retire.v1
	•	disc.overlay.advertise.v1
	•	disc.overlay.retire.v1
	•	an RPC interface:
	•	disc.query.v1
	•	disc.query.res.v1

Hubs and service operators publish descriptors to the discovery streams. Clients and the connect application:
	•	either pull the logs directly via stream() and fold them locally; or
	•	call disc.query.v1 over RPC0 against a discovery hub that has already folded the logs.

	4.	Object model

4.1 Hub descriptor

A hub descriptor describes a hub as a possible point of attachment. It is expressed as:

schema: H(“disc.hub.advertise.v1”)

body:
{
hub_id: bstr(32),      // matches VEEN hub_id
hub_pk: bstr(32),      // Ed25519 public key
profile_id: bstr(32),  // VEEN profile_id supported
region: text,          // operator-chosen, for example “ap-northeast-1”
tags: [ text, … ],   // “public”, “private”, “test”, etc.
endpoints: [           // transport-specific hints
{
kind: text,        // “http”, “https”, “quic”, “nats”
url: text          // for example “https://hub.example.com”
},
…
],
overlays: [ bstr(32), … ], // overlay identifiers this hub participates in
ttl_sec: uint,         // recommended lifetime of this advertisement
version: text          // operator-defined hub software version
}

A retirement record is:

schema: H(“disc.hub.retire.v1”)

body:
{
hub_id: bstr(32),
reason: text?
}

4.2 Overlay descriptor

Describes an overlay that can be used on the fabric.

schema: H(“disc.overlay.advertise.v1”)

body:
{
overlay_id: bstr(32),        // stable identifier for the overlay
name: text,                  // for example “rpc”, “crdt”, “wallet”
version: text,               // overlay version string
schemas: [ bstr(32), … ],  // schema identifiers used by this overlay
docs_url: text?,             // optional documentation URL
tags: [ text, … ],         // for example “stable”, “experimental”
ttl_sec: uint
}

Retirement:

schema: H(“disc.overlay.retire.v1”)

body:
{
overlay_id: bstr(32),
reason: text?
}

4.3 Service descriptor

Describes an application service. A service is a logical RPC endpoint, not tied to a single hub.

schema: H(“disc.service.advertise.v1”)

body:
{
service_id: bstr(32),       // 32-byte stable ID for the service
name: text,                 // human-readable name
overlay_id: bstr(32),       // overlay used, for example RPC overlay id
methods: [ text, … ],     // for RPC: list of supported methods
stream_ids: [ bstr(32), … ], // VEEN stream_ids this service reads/writes
regions: [ text, … ],     // preferred regions
required_caps: [ text, … ], // logical capability names, for example “read”, “write”
auth_policy: {
mode: text,               // “cap_token”, “mtls”, “none”, “other”
details: CBOR?            // overlay-specific
}?,
operator: {
org: text?,
contact: text?
}?,
tags: [ text, … ],        // “public”, “beta”, “internal”
ttl_sec: uint
}

Retirement:

schema: H(“disc.service.retire.v1”)

body:
{
service_id: bstr(32),
reason: text?
}
	5.	Discovery streams

5.1 Stream allocation

Operators choose stable stream_ids for discovery. A common pattern is:
	•	stream_id_disc_hubs    = H(“disc.hubs.v1”)
	•	stream_id_disc_services = H(“disc.services.v1”)
	•	stream_id_disc_overlays = H(“disc.overlays.v1”)

Discovery hubs advertise that they host these stream_ids in their hub descriptor.

Each discovery stream is just a normal VEEN label derived from stream_id and routing_key. Hubs do not treat these labels specially at the core layer.

5.2 Folding rules (discovery overlay state)

The discovery overlay maintains three key maps per fabric:

Hubs[label]:
key: hub_id
value: latest Hub descriptor where hub_id matches, and which is not retired and not expired.

Overlays[label]:
key: overlay_id
value: latest Overlay descriptor where overlay_id matches, not retired, not expired.

Services[label]:
key: service_id
value: latest Service descriptor where service_id matches, not retired, not expired.

Folding is defined as:
	•	Events are processed in log order (stream_seq, plus RECEIPT order if needed).
	•	For an advertise record:
	•	Insert or replace the entry keyed by hub_id / overlay_id / service_id with the payload.
	•	Compute expiry as payload.hub_ts + ttl_sec if hub_ts is available or payload.expires_at inside the body if specified; expired entries are ignored by queries.
	•	For a retire record:
	•	Mark the corresponding entry as retired; retired entries are not returned in queries.

State is always derived from the retained log prefix. Implementations MUST NOT maintain hidden mutable state outside derived maps.
	6.	Query interface (disc.query)

6.1 Schema

Queries are expressed via RPC0 as:

Request:

schema: H(“disc.query.v1”)

body:
{
kind: text,       // “hub”, “service”, “overlay”
filter: CBOR,     // filter object, structure depends on kind
limit: uint?,     // maximum number of results
offset: uint?     // optional pagination offset
}

Kinds and filters:

kind = “hub”
filter = {
region: text?,           // exact match
tags_any: [ text, … ]?,// at least one tag
overlay_id: bstr(32)?    // hubs that advertise this overlay
}

kind = “service”
filter = {
name_prefix: text?,      // name starts with prefix
method: text?,           // services exposing this method
overlay_id: bstr(32)?,   // overlay id
region: text?,           // desired region
tags_any: [ text, … ]?
}

kind = “overlay”
filter = {
name_prefix: text?,
schema: bstr(32)?,       // overlays that include this schema
tags_any: [ text, … ]?
}

Response:

schema: H(“disc.query.res.v1”)

body:
{
ok: bool,
results: [ CBOR ],   // array of descriptors, shape depends on kind
more: bool,          // true if more results may exist beyond limit+offset
error: { code: text, detail: text? }?
}

If ok = true, error MUST be absent. If ok = false, results SHOULD be empty.

6.2 Implementation of queries

A discovery hub offering RPC-based discovery:
	•	folds the discovery streams into in-memory maps Hubs, Overlays, Services;
	•	answers disc.query.v1 requests by filtering those maps deterministically;
	•	enforces a maximum limit Lmax to bound resource usage.

Connect applications MAY bypass disc.query.v1 and instead:
	•	call stream() on discovery streams;
	•	fold the descriptors locally with the same rules;
	•	run equivalent filters in-process.

	7.	Connect application behavior

The connect application is an overlay consumer that helps a client establish a working configuration to use a service. It operates in four phases:

7.1 Phase 1: hub selection

Input:
	•	User’s constraints (region, latency, tags)
	•	Optional existing pin of hub_pk

Steps:
	1.	Issue disc.query.v1 with kind = “hub” and appropriate filter.
	2.	Collect candidate hub descriptors.
	3.	Apply selection strategy:
	•	prefer region match;
	•	prefer hubs that advertise required overlays;
	•	exclude hubs whose profile_id is not supported by the client.
	4.	Return one or more candidate hubs with:
	•	endpoints;
	•	hub_pk;
	•	profile_id.

7.2 Phase 2: overlay and service selection

For a chosen hub and its fabric:
	1.	Query overlays:
	•	disc.query.v1, kind = “overlay”, filter with schema or name.
	2.	For each target overlay (for example RPC or CRDT), verify:
	•	the schemas match what the client’s overlay implementation expects.
	3.	Query services:
	•	disc.query.v1, kind = “service”, filter with:
	•	overlay_id;
	•	method (for RPC) or tag.
	4.	Return candidate services with:
	•	service_id;
	•	stream_ids to use;
	•	methods available;
	•	required_caps and auth_policy.

7.3 Phase 3: capability planning

For a selected service:
	1.	Read required_caps and auth_policy.
	2.	If auth_policy.mode == “cap_token”:
	•	determine which administrative or wallet overlay needs to issue the cap_token;
	•	either:
	•	call an issuance RPC on an admin service; or
	•	request an out-of-band cap_token from an operator.
	3.	Once a cap_token is obtained:
	•	POST it to /authorize on the chosen hub;
	•	receive auth_ref and expires_at.
	4.	Cache:
	•	service_id;
	•	hub endpoint;
	•	label / stream_ids;
	•	auth_ref and expiry.

7.4 Phase 4: bind to service

Given a selected service and auth_ref:
	1.	For RPC-based services:
	•	use the advertised stream_ids as:
	•	request label(s) for sending RPC requests;
	•	reply label(s) for receiving RPC responses.
	•	send RPC0 messages with:
	•	payload_hdr.schema = H(“rpc.v1”)
	•	body.method chosen from descriptor.methods
	•	include auth_ref in MSG.auth_ref if admission control is active.
	2.	For CRDT-based or other overlays:
	•	interpret stream_ids and schemas exactly as described in the overlay’s documentation;
	•	configure local fold logic.

The connect application MUST NOT bypass VEEN invariants or modify core behavior. It only automates selection and configuration.
	8.	Security model

8.1 Trust boundaries
	•	Discovery payloads are opaque to VEEN core; all trust is at the overlay level.
	•	Clients MUST treat discovery results as hints, not authoritative security statements.
	•	Before sending any confidential payloads, clients MUST:
	•	pin hub_pk out-of-band or via an explicit trust decision;
	•	verify RECEIPT signatures and invariants I1..I12.

8.2 Integrity of discovery data
	•	Discovery descriptors are authenticated by VEEN end-to-end properties:
	•	MSG.sig from the publisher;
	•	RECEIPT hub_sig from the discovery hub.
	•	Clients SHOULD pin:
	•	the publisher’s identity (for example operator org key) for critical services;
	•	expected overlay_ids and schemas.

8.3 Capability and exposure control
	•	Publishing a service descriptor does not grant write access. Actual access control is still via cap_token and /authorize.
	•	Operators MAY use tags and regions to distinguish:
	•	internal only services;
	•	public beta endpoints;
	•	production endpoints.

The connect application SHOULD respect these tags when proposing candidates.
	9.	Deployment patterns

Pattern A: central discovery hub
	•	One or a few hubs host the discovery streams.
	•	All other hubs and services publish discovery descriptors there.
	•	Clients contact these hubs for discovery, then connect directly to service hubs.

Pattern B: per-realm discovery
	•	Each realm or organization runs its own discovery streams and hubs.
	•	Cross-realm bridges mirror (subset) discovery descriptors using ANCHOR0/bridge mechanisms.
	•	Clients fold local realm discovery logs and optionally subscribe to remote ones.

Pattern C: client-only folding
	•	Discovery streams are public and readable via stream(with_proof=1).
	•	Connect applications fold discovery logs locally without an RPC query API.

	10.	Non-goals

The discovery overlay does not intend to:
	•	replace general-purpose service mesh discovery protocols;
	•	perform load balancing or health checking at runtime;
	•	override local policy decisions about which hubs or services are trusted;
	•	enforce any specific economic or billing model.

It is a minimal, log-derived directory of what exists and how to reach it over VEEN.
	11.	Summary

Discovery Overlay and Connect Application v0.0.1:
	•	define schemas and folding rules to advertise hubs, overlays, and services;
	•	provide a simple RPC query interface for filtered lookups;
	•	describe a connect application that selects hubs and services, obtains capabilities, and binds to overlays;
	•	keep all changes strictly at the overlay level, leaving VEEN core unchanged.

With this overlay in place, hubs and overlays become discoverable resources on the same fabric, and clients can programmatically “ask the network” which applications are available and how to connect to them, without any new core wire objects or error codes.
