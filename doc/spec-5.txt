Discovery Overlay and Connect Application Specification v0.0.1
Plain ASCII, English only
	0.	Purpose and scope

0.1 Purpose

This document refines the v0.0.1 discovery overlay and connect application for VEEN fabrics. It keeps the same version number and functional scope, but tightens:
	•	identifier conventions;
	•	state models;
	•	folding rules;
	•	matching and scoring semantics;
	•	idempotency and security behavior.

No hub changes are required. All behavior is expressed as schemas and deterministic folds over logs.

0.2 In-scope

This specification defines:
	•	how applications publish their capabilities into a fabric;
	•	how clients express discovery intent;
	•	how a connect application derives matches and issues connect grants;
	•	how all of this remains:
	•	deterministic;
	•	replayable from logs;
	•	independent of OS, container runtime, or hub topology.

0.3 Out-of-scope

This document does not define:
	•	concrete HTTP or RPC protocols for application payloads;
	•	distributed scheduling or load balancing algorithms;
	•	billing, pricing, or SLAs beyond simple descriptive fields;
	•	any hub-side behavior beyond VEEN v0.0.1 core.

	1.	Version and compatibility

1.1 Version
	•	Overlay version: v0.0.1.
	•	All schemas in this document are tagged v1.
	•	Future overlay versions MUST be able to:
	•	fold the same log prefixes;
	•	reproduce v0.0.1-derived state for v1 schemas; and
	•	avoid reinterpretation of v1 events.

1.2 Compatibility guarantees

Given a fixed VEEN core v0.0.1 and a fixed log prefix:
	•	Any conforming discovery overlay implementation MUST produce bitwise-equivalent state:
	•	app_registry;
	•	indices;
	•	query_registry.
	•	Any conforming connect application, when configured with the same policy parameters, MUST:
	•	emit identical app.discovery.reply.v1 and app.connect.grant.v1 payloads;
	•	or reject requests in the same cases.

	2.	Model overview

2.1 Roles
	•	Provider:
	•	owns one or more applications;
	•	publishes catalog entries.
	•	Client:
	•	wants to locate and use applications;
	•	emits discovery queries and connect requests.
	•	Connect application:
	•	reads catalog and queries;
	•	produces replies and grants;
	•	issues capability tokens for application access.
	•	VEEN core:
	•	transports encrypted payloads;
	•	commits events into logs and receipts;
	•	enforces core invariants.

2.2 Streams and labels

Recommended (not mandatory) labels:
	•	app/catalog
	•	app.catalog.register.v1
	•	app.catalog.retire.v1
	•	app/discovery
	•	app.discovery.query.v1
	•	app.discovery.reply.v1
	•	app/connect
	•	app.connect.request.v1
	•	app.connect.grant.v1

Folding MUST be defined only in terms of:
	•	payload_hdr.schema;
	•	payload body bytes;
	•	stream_seq and label;

and MUST NOT assume specific label names.

2.3 Determinism

For any finite log prefix P, let fold_discovery(P) denote the overlay state. Requirements:
	•	fold_discovery(P) depends only on P (order-preserving).
	•	fold_discovery(P) ignores:
	•	which hub accepted messages;
	•	OS, kernel, or container runtime;
	•	network topology.
	•	Replaying P in any order consistent with stream_seq MUST produce the same state.

	3.	Identifiers and conventions

3.1 Cryptographic hash function
	•	H is a fixed 256-bit hash function (for example SHA-256).
	•	All hashes in this document are:
	•	output length: 32 bytes;
	•	encoded as raw bstr in CBOR.

3.2 app_id
	•	app_id: bstr[32].
	•	Suggested derivation (not enforced by overlay):
app_id = H(provider_principal_id || 0x3a || local_app_name_bytes)
where 0x3a is the ASCII colon “:” and local_app_name_bytes is UTF-8.
	•	Treat app_id as opaque in overlay folding.

3.3 connect_id
	•	connect_id: bstr[32].
	•	MUST be globally unique within the fabric for the life of the log prefix.
	•	Recommended derivation:
connect_id = H(requester_principal_id || requester_client_id || app_id || query_id || nonce)

3.4 query_id
	•	query_id: bstr[32].
	•	MUST be chosen by the client to uniquely identify a discovery intent.
	•	It is treated as opaque by the overlay.

3.5 Realm and context
	•	realm_id: bstr[32], defined by identity overlay.
	•	ctx_id: bstr[32], defined by identity overlay.

	4.	Schemas

All schemas are CBOR maps with fixed required keys. Additional unknown keys MUST be ignored by folding logic.

4.1 app.catalog.register.v1

Type: application catalog registration.

Fields:
	•	app_id: bstr[32]
	•	provider_principal_id: bstr[32]
	•	realm_id: bstr[32]
	•	ctx_id: bstr[32]
	•	version: text
	•	exposed_schemas: array of bstr[32]
	•	endpoint_kind: text
	•	endpoint_locator: text
	•	auth_profile: text
	•	pricing_model: text
	•	tags: array of text
	•	attributes: map<text, any> (may be empty or omitted)

Constraints:
	•	exposed_schemas MUST NOT contain duplicates (duplicates are ignored).
	•	tags MUST NOT contain duplicates (deduplicate by first occurrence).
	•	Strings MAY be UTF-8; comparison MUST be byte-wise.

4.2 app.catalog.retire.v1

Type: application retirement.

Fields:
	•	app_id: bstr[32]
	•	realm_id: bstr[32]
	•	ctx_id: bstr[32]
	•	version: text
	•	reason: text (optional, may be empty)

4.3 app.discovery.query.v1

Type: discovery query.

Fields:
	•	query_id: bstr[32]
	•	requester_client_id: bstr[32]
	•	realm_id: bstr[32]
	•	ctx_id: bstr[32]
	•	required_schemas: array of bstr[32] (may be empty)
	•	optional_schemas: array of bstr[32] (may be empty)
	•	required_tags: array of text (may be empty)
	•	forbidden_tags: array of text (may be empty)
	•	min_version: text (optional)
	•	max_version: text (optional)
	•	auth_requirements: text
	•	limit: uint
	•	client_constraints: map<text, any> (may be empty or omitted)

Constraints:
	•	limit MUST be > 0.
	•	Version strings are compared lexicographically as byte sequences.

4.4 app.discovery.reply.v1

Type: discovery reply.

Fields:
	•	query_id: bstr[32]
	•	responder_principal_id: bstr[32]
	•	matches: array of:
	•	app_id: bstr[32]
	•	realm_id: bstr[32]
	•	ctx_id: bstr[32]
	•	version: text
	•	endpoint_kind: text
	•	endpoint_locator: text
	•	auth_profile: text
	•	pricing_model: text
	•	score: float or numeric (implementation-defined, MUST be deterministic)
	•	reason: text
	•	hint_connect_id: bstr[32] (optional)
	•	exhausted: bool

4.5 app.connect.request.v1

Type: connect request.

Fields:
	•	connect_id: bstr[32]
	•	query_id: bstr[32] (optional, may be zero bytes)
	•	requester_client_id: bstr[32]
	•	app_id: bstr[32]
	•	realm_id: bstr[32]
	•	ctx_id: bstr[32]
	•	requested_version: text
	•	requested_endpoint_kind: text
	•	requested_endpoint_locator: text (may be empty)
	•	requested_lifetime_seconds: uint
	•	requested_rate:
	•	messages_per_window: uint
	•	window_seconds: uint
	•	usage_purpose: text

Constraints:
	•	requested_lifetime_seconds MUST be > 0.
	•	requested_rate.window_seconds MUST be > 0.

4.6 app.connect.grant.v1

Type: connect grant.

Fields:
	•	connect_id: bstr[32]
	•	requester_client_id: bstr[32]
	•	app_id: bstr[32]
	•	realm_id: bstr[32]
	•	ctx_id: bstr[32]
	•	granted_version: text
	•	endpoint_kind: text
	•	endpoint_locator: text
	•	cap_token: bstr (serialized VEEN cap_token)
	•	effective_lifetime_seconds: uint
	•	effective_rate:
	•	messages_per_window: uint
	•	window_seconds: uint
	•	constraints: map<text, any>
	•	audit_note: text

Constraints:
	•	effective_lifetime_seconds MUST be > 0.
	•	effective_rate.window_seconds MUST be > 0.
	•	effective values MUST be less than or equal to requested where a request exists.

	5.	Overlay state model

5.1 State components

Let S be the discovery overlay state. S consists of:
	•	app_registry: map K_app -> AppEntry
	•	app_status: map K_app -> Status (“active” or “retired”)
	•	index_by_tag: map Tag -> set K_app
	•	index_by_schema: map SchemaId -> set K_app
	•	query_registry: map QueryId -> QueryEntry

where:
	•	K_app = (realm_id, app_id, version_bytes)
	•	Tag = text (byte-wise exact match)
	•	SchemaId = bstr[32]
	•	QueryId = bstr[32]

AppEntry fields:
	•	app_id
	•	provider_principal_id
	•	realm_id
	•	ctx_id
	•	version
	•	exposed_schemas (deduplicated array)
	•	endpoint_kind
	•	endpoint_locator
	•	auth_profile
	•	pricing_model
	•	tags (deduplicated array)
	•	attributes
	•	last_stream_seq: uint
	•	last_leaf_hash: bstr[32]

QueryEntry fields:
	•	parsed query body (fields of app.discovery.query.v1)
	•	last_stream_seq: uint
	•	last_leaf_hash: bstr[32]

5.2 Initialization

At the beginning (empty log prefix):
	•	app_registry is empty.
	•	app_status is empty.
	•	index_by_tag and index_by_schema are empty.
	•	query_registry is empty.

	6.	Folding rules

6.1 General ordering

Events are processed in the order defined by their label stream_seq for each label, and then by tie-breakers:
	•	Primary ordering: label (arbitrary but fixed comparison);
	•	Secondary: stream_seq ascending;
	•	Tertiary (for exact ties, e.g. mirrors): leaf_hash ascending (lexicographic).

For a single physical log produced by VEEN, stream_seq ordering for a given label is already total. Ties only arise in mirrored or bridged scenarios.

6.2 Folding app.catalog.register.v1

Given an event R with:
	•	K = (realm_id, app_id, version_bytes)
	•	seq = stream_seq
	•	leaf = leaf_hash

Step:
	1.	If K not in app_registry:
	•	Insert new AppEntry using fields from R.
	•	Set last_stream_seq = seq, last_leaf_hash = leaf.
	•	Set app_status[K] = “active”.
	2.	Else K exists with entry E:
	•	If seq > E.last_stream_seq:
	•	Replace E with new AppEntry from R.
	•	Else if seq == E.last_stream_seq and leaf > E.last_leaf_hash lexicographically:
	•	Replace E with new AppEntry from R.
	•	Else:
	•	Ignore R (older or dominated).
	•	In all replacement cases, set last_stream_seq, last_leaf_hash accordingly.
	•	Set app_status[K] = “active”.
	3.	Update indices:
	•	Remove K from all index_by_tag and index_by_schema entries where it may appear.
	•	For each tag in R.tags:
	•	Insert K into index_by_tag[tag].
	•	For each schema_id in R.exposed_schemas:
	•	Insert K into index_by_schema[schema_id].

6.3 Folding app.catalog.retire.v1

Given an event X with key K = (realm_id, app_id, version_bytes):
	1.	Look up existing last_stream_seq and last_leaf_hash for K if any; treat missing as (0, zero_hash).
	2.	Apply dominance rule:
	•	If seq > last_stream_seq:
	•	accept retirement.
	•	Else if seq == last_stream_seq and leaf > last_leaf_hash:
	•	accept retirement.
	•	Else:
	•	ignore X.
	3.	If accepted:
	•	Set app_status[K] = “retired”.
	•	Remove K from index_by_tag[] and index_by_schema[].
	•	Keep any AppEntry for K in app_registry but marked indirectly as retired, to preserve metadata if needed.

6.4 Folding app.discovery.query.v1

Given a query Q:
	•	Key: query_id.
	•	Extract seq, leaf.

	1.	If query_id not in query_registry:
	•	Insert QueryEntry for Q with last_stream_seq = seq, last_leaf_hash = leaf.
	2.	Else existing entry E:
	•	If seq > E.last_stream_seq, replace with Q.
	•	Else if seq == E.last_stream_seq and leaf > E.last_leaf_hash, replace with Q.
	•	Else ignore.

No indices are updated; queries are looked up by query_id.

6.5 app.discovery.reply.v1 and connect events
	•	app.discovery.reply.v1:
	•	Does not change discovery overlay state S.
	•	Used by clients; can be audited from logs.
	•	app.connect.request.v1 and app.connect.grant.v1:
	•	Not folded into discovery overlay S in v0.0.1.
	•	A separate “connect overlay” could track them, but this is out-of-scope here.

	7.	Connect application behavior

7.1 Determinism requirements

The connect application is not part of the overlay, but its behavior MUST be deterministic given:
	•	discovery overlay state S as defined above;
	•	ordered stream of new events;
	•	configuration parameters (policy) that are constants for the run.

No random selection is allowed in v0.0.1.

7.2 Matching algorithm for queries

When a new or updated QueryEntry Q is observed, the connect application MAY produce a reply. A typical policy is “reply on first observation of each query_id”.

Given Q:
	•	extract:
	•	realm_id_q
	•	required_schemas_q
	•	optional_schemas_q
	•	required_tags_q
	•	forbidden_tags_q
	•	min_version_q, max_version_q
	•	auth_requirements_q
	•	limit_q

7.2.1 Candidate selection

Define candidate set C as all K_app such that:
	•	app_status[K_app] == “active”;
	•	app_registry[K_app].realm_id == realm_id_q;
	•	Version constraint:
	•	If min_version_q present: app.version >= min_version_q (lexicographic).
	•	If max_version_q present: app.version <= max_version_q (lexicographic).
	•	Schema constraint:
	•	Every s in required_schemas_q is present in app.exposed_schemas.
	•	Tag constraints:
	•	Every t in required_tags_q is present in app.tags.
	•	None of t in forbidden_tags_q is present in app.tags.
	•	Auth constraint:
	•	Interpretation is policy-specific, but MUST be deterministic.
	•	At minimum, the connect application MUST define a mapping:
f_auth(auth_profile, pricing_model, auth_requirements_q) -> bool
and include only apps for which f_auth returns true.

7.2.2 Scoring

For each candidate K in C, compute a score S(K):
	•	Let A = app_registry[K].
	•	Let:
	•	m_req_schema = count of required_schemas_q satisfied by A (this is equal to len(required_schemas_q) if candidate passes).
	•	m_opt_schema = count of s in optional_schemas_q that appear in A.exposed_schemas.
	•	m_req_tag = count of required_tags_q satisfied.
	•	version_recency = a numeric derived from A.version (for example lexicographic rank; deterministic).
	•	Example score function (illustrative, not mandatory):
S(K) = 1000 * m_req_schema
+ 100 * m_opt_schema
+ 10 * m_req_tag
+ version_recency

The actual function MUST be fixed and documented by the implementation. Once chosen, it MUST NOT depend on external time or random sources.

7.2.3 Ordering

Sort candidates by:
	1.	score descending;
	2.	app_id ascending (lexicographic bstr);
	3.	version ascending (lexicographic text).

7.2.4 Truncation and reply production
	•	Let M be the sorted list of candidates.
	•	Let M_limit be the first min(limit_q, len(M)) elements.
	•	Compute exhausted flag:
	•	exhausted = (len(M_limit) == len(M))
	•	Construct app.discovery.reply.v1 with:
	•	query_id = Q.query_id;
	•	responder_principal_id = principal_id of the connect application;
	•	matches:
	•	for each K in M_limit, include fields copied from app_registry[K] and computed score, plus a deterministic reason string.
	•	exhausted as above.
	•	Emit reply on app/discovery (or configured label).

7.3 Connect handling

Given app.connect.request.v1 R:
	•	Look up K = (R.realm_id, R.app_id, requested_version).
	•	If app_status[K] != “active”, reject (implementation MUST define a rejection path, e.g. error log or overlay event).
	•	Retrieve AppEntry A = app_registry[K].

7.3.1 Policy evaluation

From R and A, derive:
	•	requested lifetime and rate.
	•	allowed lifetime and rate from policy functions:
lifetime_eff = min(requested_lifetime_seconds, policy_max_lifetime(A))
rate_eff = min_componentwise(requested_rate, policy_max_rate(A))

If lifetime_eff == 0 or rate_eff.window_seconds == 0 or rate_eff.messages_per_window == 0, reject.

7.3.2 Endpoint selection
	•	endpoint_kind_eff:
	•	either A.endpoint_kind; or
	•	a policy-permitted alternative consistent with A (for example redirect to a newer version).
	•	endpoint_locator_eff:
	•	either A.endpoint_locator; or
	•	a derived locator consistent with K.

7.3.3 cap_token issuance

The connect application acts as capability issuer:
	•	issuer_pk: connect application’s public key.
	•	subject_pk: derived from requester_client_id and identity overlay.
	•	allow:
	•	label or stream identifier corresponding to the application endpoint within VEEN;
	•	rate and lifetime derived from lifetime_eff and rate_eff.
	•	sig_chain: as defined by VEEN capability overlay.

The cap_token MUST:
	•	scope access at most to the required app label or stream;
	•	not grant broader access than policy allows.

7.3.4 Grant construction

Construct app.connect.grant.v1:
	•	connect_id = R.connect_id.
	•	requester_client_id = R.requester_client_id.
	•	app_id, realm_id, ctx_id from A.
	•	granted_version = A.version (or a policy-defined compatible version).
	•	endpoint_kind = endpoint_kind_eff.
	•	endpoint_locator = endpoint_locator_eff.
	•	cap_token = serialized token bytes.
	•	effective_lifetime_seconds = lifetime_eff.
	•	effective_rate = rate_eff.
	•	constraints: implementation-defined, e.g. {“allowed_schemas”: [..]}.
	•	audit_note: short text describing decision.

Emit grant on app/connect.

7.4 Idempotency

For idempotency:
	•	Define a function canonical_grant(R, S, policy) that returns either:
	•	a deterministic grant body; or
	•	a rejection.

For any R with the same connect_id and body:
	•	The connect application MUST either:
	•	emit exactly one grant whose body equals canonical_grant(R, S, policy); or
	•	emit no grant and treat the request as rejected.

One practical approach:
	•	Maintain in memory a map:
	•	connect_id -> hash(grant_body)
	•	On first processing of R:
	•	compute grant_body;
	•	emit grant;
	•	store hash(grant_body).
	•	On subsequent processing of the same R:
	•	recompute grant_body;
	•	verify hash matches stored value;
	•	optionally re-emit or suppress duplicate output.

	8.	Security and trust

8.1 Trust model
	•	Clients trust:
	•	their own keys;
	•	pinned connect application principal(s);
	•	identity overlay to bind principal_id and client_id.
	•	Connect applications trust:
	•	VEEN logs and receipts;
	•	identity overlay for requester lookup;
	•	catalog entries emitted by providers.

8.2 Attack surfaces

The overlay and connect application MUST handle:
	•	Malicious or malformed catalog entries:
	•	overlay MUST ignore structurally invalid payloads;
	•	connect application MUST treat inconsistent entries as ineligible.
	•	Query spam:
	•	connect application MAY rate limit per requester_client_id using separate overlays or policies.
	•	Conflicting catalog announcements:
	•	resolved via deterministic tie-breaking rules in section 6.

8.3 Confidentiality
	•	All payloads are encrypted end-to-end by VEEN core.
	•	Connect applications and providers see decrypted catalog and query contents by design.
	•	Hubs see only ciphertext and core headers.

	9.	Error handling

9.1 Overlay-level
	•	Structurally invalid CBOR for a known schema:
	•	MUST be treated as “no-op” for overlay folding;
	•	MAY be logged or exposed as diagnostics outside overlay state.
	•	Unknown schema_id:
	•	MUST be ignored by the discovery overlay.

9.2 Connect application-level
	•	If a request R fails policy checks:
	•	connect application MUST NOT emit a grant with cap_token;
	•	it MAY emit an explicit “denied” event using a separate schema (out-of-scope here).

	10.	Observability (optional)

Implementations MAY publish:
	•	app.discovery.metrics.v1:
	•	counts of catalog entries, active apps, queries, replies.
	•	app.connect.metrics.v1:
	•	grants issued per app_id, per realm_id, per requester.

These facilities do not affect overlay state and are not required for correctness.
	11.	Non-goals

The v0.0.1 discovery overlay and connect application do not attempt to:
	•	model complex negotiation of SLAs or pricing;
	•	handle multi-hop routing or federation across independent fabrics;
	•	encode load or health into the overlay itself.

The sole responsibility in v0.0.1 is:
	•	express what applications exist;
	•	express what clients want;
	•	determinstically map from “want” to “capability token plus endpoint” using only logs, identity, and fixed policies.
