⸻

0. Top-Level Structure

You have three main entrypoints from WSL:
	•	veen-hub – hub process (core + overlays)
	•	veen-cli – client / admin / test driver
	•	veen-selftest – orchestration for integration + unit/property/fuzz tests

Top-level test goals

From WSL, all of these must succeed:

veen-selftest core        # v0.0.1 core (wire, crypto, MMR, invariants, RPC/CRDT/ANCHOR/OBS/COMP/SH0/DR0/TS0)
veen-selftest overlays    # v0.0.1+ overlays (FED1, AUTH1, KEX1+, SH1+, LCLASS0, META0+)
veen-selftest all         # runs both suites end-to-end

If veen-selftest all is green on WSL, the implementation is considered complete.

⸻

1. Core Integration GOALs (VEEN v0.0.1)

1.1 Core E2E messaging + receipts + verification

GOAL: From WSL, you can spin up a single hub and do full E2E:
	•	Generate keys for a client.
	•	Send an encrypted MSG to a stream.
	•	Receive the MSG and decrypt it.
	•	Verify the RECEIPT and MMR root against the local view.

Key flows:

# Start hub
veen-hub run \
  --listen 127.0.0.1:8080 \
  --data-dir ~/.veen/hub-core

# Create a client
veen-cli keygen --out ~/.veen/client1

# Send a message
veen-cli send \
  --hub http://127.0.0.1:8080 \
  --client ~/.veen/client1 \
  --stream core/main \
  --body '{"text":"hello-veens"}' \
  --dump-raw msg.cbor receipt.cbor

# Stream + decrypt
veen-cli stream \
  --hub http://127.0.0.1:8080 \
  --client ~/.veen/client1 \
  --stream core/main \
  --from 1

# Verify RECEIPT + MMR
veen-cli verify-receipt --receipt receipt.cbor --stream core/main

Acceptance:
	•	MSG ciphertext is opaque to the hub (no plaintext in hub logs).
	•	verify-receipt confirms I1–I3 and MMR root for that label.
	•	Deterministic CBOR: re-encoding the same struct yields identical bytes.

⸻

1.2 Attachments (section 10)

GOAL: Attachments are encrypted, committed via att_root, and verifiable.

Flow:

veen-cli send-with-attachment \
  --hub http://127.0.0.1:8080 \
  --client ~/.veen/client1 \
  --stream core/att \
  --file ./big.bin \
  --dump-raw msg_att.cbor receipt_att.cbor

veen-cli verify-attachment \
  --msg msg_att.cbor \
  --file ./big.bin

Acceptance:
	•	verify-attachment recomputes coid and att_root and matches payload_hdr.att_root.
	•	Any mutation of attachment bytes or att_root leads to rejection or verification failure.

⸻

1.3 Capabilities + admission + error codes (sections 11, 13, 21)

GOAL: Permissioned writes with rate limiting and correct E.* codes.

Flow:

# Admin identity
veen-cli keygen --out ~/.veen/admin

# Issue cap_token
veen-cli cap issue \
  --issuer ~/.veen/admin \
  --subject ~/.veen/client1.pub \
  --stream core/capped \
  --ttl 600 \
  --rate "5/s,10" \
  --out cap_client1.cbor

# Authorize on hub
veen-cli cap authorize \
  --hub http://127.0.0.1:8080 \
  --cap cap_client1.cbor

Tests:
	1.	Write without cap → E.AUTH / HTTP 403
	2.	Write with valid cap → success + RECEIPT
	3.	Exceed rate → E.RATE / HTTP 429
	4.	Use expired cap → E.CAP
	5.	Unknown profile_id, profile mismatch, etc. → E.PROFILE / HTTP 400
	6.	Dup (client_id, client_seq) → E.SEQ or E.DUP / HTTP 409

All via veen-selftest core subtests.

⸻

1.4 RESYNC + durable client state (RESYNC0)

GOAL: Client can lose its local state and fully reconstruct it from hub.

Flow:

# Load a stream with messages
veen-cli bench send \
  --hub http://127.0.0.1:8080 \
  --client ~/.veen/client1 \
  --stream core/resync \
  --count 1000

# Destroy local client state
rm -rf ~/.veen/state/client1/*

# Resync from hub
veen-cli resync \
  --hub http://127.0.0.1:8080 \
  --client ~/.veen/client1 \
  --stream core/resync

# Verify local state vs hub
veen-cli verify-state \
  --hub http://127.0.0.1:8080 \
  --client ~/.veen/client1 \
  --stream core/resync

Acceptance:
	•	verify-state confirms last_stream_seq and last_mmr_root match the hub.
	•	RESYNC uses stream?from= and CHECKPOINT correctly; no holes, no divergences.

⸻

1.5 RPC overlay (RPC0)

GOAL: Request/response RPC over VEEN works end-to-end.

Flow:

veen-cli rpc call \
  --hub http://127.0.0.1:8080 \
  --client ~/.veen/client1 \
  --stream rpc/main \
  --method "add" \
  --args '{"a":1,"b":2}' \
  --timeout-ms 5000

Acceptance:
	•	Request uses schema = H("rpc.v1"), reply uses schema = H("rpc.res.v1").
	•	Replies carry parent_id = request.msg_id.
	•	ok:true => result present; ok:false => error present.
	•	Idempotency: repeated (method, client_id, idem) yields the same result and no duplicate side-effects.

⸻

1.6 CRDT overlay (CRDT0)

GOAL: LWW, OR-Set, and G-Counter semantics hold when replayed via VEEN logs.

Examples:
	•	LWW register:

veen-cli crdt-lww set \
  --hub http://127.0.0.1:8080 \
  --client ~/.veen/client1 \
  --stream crdt/main \
  --key foo \
  --value "A" \
  --ts 1

veen-cli crdt-lww set \
  --hub http://127.0.0.1:8080 \
  --client ~/.veen/client1 \
  --stream crdt/main \
  --key foo \
  --value "B" \
  --ts 2

veen-cli crdt-lww get \
  --hub http://127.0.0.1:8080 \
  --stream crdt/main \
  --key foo
# => "B"

	•	OR-Set, G-Counter have analogous flows.

Acceptance:
	•	Snapshots up to upto_seq are deterministic and match the CRDT spec.
	•	Replaying from CHECKPOINT + receipts yields the same CRDT state.

⸻

1.7 Anchoring (ANCHOR0)

GOAL: Hub anchors MMR roots externally and auditors can verify the binding.

Flow:
	•	Start hub with anchoring backend configured (file or dummy ledger).
	•	Let hub run until it emits CHECKPOINTs with anchor_ref.
	•	From WSL:

veen-cli verify-anchor \
  --checkpoint checkpoint.cbor

Acceptance:
	•	verify-anchor confirms mmr_root → anchor_ref → external backend is consistent.
	•	Anchor cadence (K receipts or T minutes) is respected.

⸻

1.8 Observability / Compliance / Hardening (OBS0, COMP0, SH0, DR0)

GOAL: Core operational edges exist and behave as specified.

Checks:
	•	/healthz returns {ok, profile_id, peaks_count, last_stream_seq, last_mmr_root}.
	•	Metrics include veen_submit_ok_total, veen_submit_err_total{code}, latency histograms, etc.
	•	Logs are structured JSON per submit (label, client_id_prefix, stream_seq, leaf_hash_prefix, code?, bytes_in, bytes_out, verify_ms, commit_ms).
	•	Retention and file rotation work (receipts.cborseq, payloads.cborseq, checkpoints.cborseq + index sidecars).
	•	TLS uses AEAD suites and no compression; bounds checks happen before expensive crypto.

All covered by veen-selftest core via combined integration + small unit/property tests.

⸻

2. Overlay Integration GOALs (VEEN v0.0.1+)

These are the “+” features: FED1, AUTH1, KEX1+, SH1+, LCLASS0, META0+.

2.1 Federation & single-primary discipline (FED1 + AUTH1)

GOAL: Primary/replica/bridge topology with single writer per label.

Flow (from WSL):

# primary hub
veen-hub run \
  --role primary \
  --listen 127.0.0.1:8080 \
  --data-dir ~/.veen/hub-primary

# replica hub
veen-hub run \
  --role replica \
  --listen 127.0.0.1:8081 \
  --data-dir ~/.veen/hub-replica

# bridge primary -> replica
veen-bridge run \
  --from http://127.0.0.1:8080 \
  --to   http://127.0.0.1:8081

Set authority:

PRIMARY_ID=$(veen-cli hub-id --hub http://127.0.0.1:8080)
REPLICA_ID=$(veen-cli hub-id --hub http://127.0.0.1:8081)

veen-cli authority set \
  --realm default \
  --stream fed/chat \
  --primary-hub $PRIMARY_ID \
  --replica-hub $REPLICA_ID

Tests:
	1.	Send to primary → success.
	2.	Send directly to replica → E.AUTH/E.CAP (not primary for label).
	3.	Stream from replica → primary’s events appear via bridge.
	4.	On both hubs, veen-cli audit --stream fed/chat shows identical mmr_root and stream_seq.

All run by veen-selftest overlays --subset fed-auth.

⸻

2.2 Key/identity lifecycle and revocation (KEX1+)

GOAL: Enforce client_id lifetime, per-client msg caps, and revocation.

Flow:
	•	Start hub with:
	•	max_client_id_lifetime_sec
	•	max_msgs_per_client_id_per_label
	•	Use veen-cli to:
	1.	Hit the message cap for a client_id → next send fails with E.CAP/E.AUTH.
	2.	Wait (or simulate) client_id lifetime expiry → sends fail.
	3.	Revoke client-id, auth-ref, cap-token via:

veen-cli revoke \
  --hub http://127.0.0.1:8080 \
  --kind client-id|auth-ref|cap-token \
  --target <value>



Acceptance:
	•	All three revocation kinds take effect immediately for new writes.
	•	Revocation state is carried in the log and can be audited.

⸻

2.3 Hardening pipeline (SH1+)

GOAL: Full Stage0–Stage3 admission pipeline behaves correctly under normal and adversarial load.

Checks (driven by veen-selftest overlays --subset sh1):
	•	Oversized payloads fail at Stage0 (length checks) with E.SIZE / HTTP 413.
	•	Malformed CBOR / unknown keys fail at Stage1 with E.SIZE.
	•	Bad signatures fail at Stage2 with E.SIG / HTTP 409.
	•	Unauthorized / over-rate traffic fails at Stage2 with E.AUTH/E.CAP/E.RATE.
	•	Invariant violations fail at Stage3 with E.SEQ/E.DUP/E.PROFILE.
	•	Optional PoW / stateless cookie: requests without a valid cookie are blocked during overload; valid cookie passes.

Bounds-first is enforced: crypto is not invoked for obvious garbage.

⸻

2.4 Label classification (LCLASS0)

GOAL: Label classes influence padding, rate, and retention without exposing payload contents.

Flow:

# Set label classes as admin
veen-cli label-class set \
  --realm default \
  --label chat/user \
  --class user \
  --sensitivity medium \
  --retention-hint 86400

veen-cli label-class set \
  --realm default \
  --label wallet/main \
  --class wallet \
  --sensitivity high \
  --retention-hint 2592000

veen-cli label-class set \
  --realm default \
  --label log/ingest \
  --class log \
  --sensitivity low \
  --retention-hint 86400

# Inspect classification view
veen-cli label-class show \
  --hub http://127.0.0.1:8080 \
  --label HEX32 \
  --json

veen-cli label-class list \
  --hub http://127.0.0.1:8080 \
  --class user

Tests:
	•	Short payloads to each label must result in different ciphertext lengths per configured pad_block (e.g. 256 vs 1024 vs 0).
	•	Rate-limit and retention policies follow the label class configuration.
	•	All of this happens without hub ever seeing decrypted payloads.
	•	veen-cli label-class show/list reflect the hub’s classification view in text and JSON output.

⸻

2.5 Schema metadata (META0+)

GOAL: Schema registry maps schema_id to human-readable metadata and coordinates overlays (RPC, wallet, CRDT, etc.).

Flow:

# Register a schema
SCHEMA_ID=$(veen-cli schema-id "wallet.transfer.v1")

veen-cli schema register \
  --realm default \
  --schema-id $SCHEMA_ID \
  --name "wallet.transfer.v1" \
  --version "v1" \
  --doc-url "https://example.com/wallet-transfer" \
  --owner ~/.veen/admin.pub

# Use schema in a wallet-like message
veen-cli wallet transfer \
  --hub http://127.0.0.1:8080 \
  --client ~/.veen/client1 \
  --stream wallet/main \
  --to "user2" \
  --amount "100"

Acceptance:
	•	veen-cli schema list shows the registered schema.
	•	Messages that use this schema_id can be introspected by tooling (debug/CLI) even though the hub sees only ciphertext.
	•	Unregistered/unknown schemas are still transmitted, but tooling can report them as “unknown schema”.

⸻

2.6 Combined overlay scenario

GOAL: All overlays cooperate correctly in one integrated run.

Scenario (driven by veen-selftest overlays-full):
	•	Primary + replica + bridge.
	•	Label classes configured.
	•	Schema metadata registered for some RPC/CRDT/wallet messages.
	•	cap_token issued, authorized, then revoked.
	•	High RPS traffic to mixed labels (wallet, chat, log, admin) under SH1.
	•	Clients RESYNC after state loss.
	•	primary and replica remain consistent (mmr_root, CHECKPOINT, anchor).
	•	No hub crashes, correct E.* codes everywhere, and health/metrics/logs stay consistent.

If this full scenario passes from WSL, the overlay feature set is considered complete.

⸻

3. Final Acceptance: What “DONE” Means

VEEN v0.0.1+ implementation is “DONE” when:
	1.	From WSL, you can:
	•	Start hubs (single, primary/replica),
	•	Run clients and admin flows via veen-cli,
	•	Exercise all core and overlay behaviours as above.
	2.	veen-selftest core passes:
	•	Core wire format, crypto, MMR, invariants, RPC, CRDT, anchoring, observability, compliance, hardening, deployment mappings.
	3.	veen-selftest overlays passes:
	•	Federation (FED1), authority discipline (AUTH1), key/cap lifecycle and revocation (KEX1+), hardening pipeline (SH1+), label classification (LCLASS0), and schema metadata (META0+).
	4.	veen-selftest all is green on your WSL environment without manual intervention.

At that point you can say, in a very literal sense:

“From WSL, I can operate a full VEEN v0.0.1+ fabric – core + overlays – and verify every property the spec claims, via integration tests.”
